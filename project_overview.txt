# Project File Tree

.
  |-components
  |-lib
  |-node_modules
  |-pages
  |  |-api
  |-src
  |  |-.dev
  |  |  |-advancedGroupFilter
  |  |  |-images
  |  |  |-loaders
  |  |  |  |-css-sandbox
  |  |  |-login
  |  |  |  |-takePictureDialog
  |  |  |-navbar
  |  |  |-styles
  |  |-app
  |  |  |-images
  |  |  |-scripts
  |  |  |  |-components
  |  |  |  |-contexts
  |  |  |  |-utils
  |  |  |-styles


# File Contents



## File: ./zip.util.js

```js
/*eslint-disable*/
const fs = require('fs');
const archiver = require('archiver');
const path = require('path');
const config = require('./src/config.json');

const { name: appName } = config;
const output = fs.createWriteStream(`${appName}.zip`);
const archive = archiver('zip');

output.on('close', () => {
  console.log(`${archive.pointer()} total bytes`);
  console.log('archiver has been finalized and the output file descriptor has closed.');
});

archive.on('error', (err) => {
  throw err;
});

archive.pipe(output);

// append files from a sub-directory and naming it `new-subdir` within the archive
archive.directory(path.join(__dirname, 'dist'), appName);

archive.finalize();
```


## File: ./next.config.js

```js
```


## File: ./webpack.config.js

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CopyWebpackPlugin = require('copy-webpack-plugin');
const config = require('./src/config.json');

const { name: appName } = config;

const transform = function (content, path) {
  let config = JSON.parse(content);
  let host = config.dev.dist.host;
  let len = config.items.length;
  const { name } = config;

  for (let i = 0; i < len; i++) {
    
    config.items[i].url = `${name}/` + config.items[i].url;
    
    
    
  }

  delete config['dev'];
  let response = JSON.stringify(config, null, 2);
  // Returned string is written to file
  return response;
}

const jsFileName = () => {
  let fileName = '[name]-[contenthash].js'
  
  return fileName
}

module.exports = {
  mode: 'production',
  entry: {
    bundle: path.resolve(__dirname, 'src/app/index.js'),
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: jsFileName,
    assetModuleFilename: '[name][ext]',
    clean: true
  },
  devServer: {
    static: {
      directory: path.resolve(__dirname, 'dist')
    },
    port: 3000,
    open: true,
    hot: true,
    compress: true,
    historyApiFallback: true
  },
  devtool: 'source-map',
  
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
  },
  
  module: {
    rules: [
      {
        test: /\.scss/,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader'
        ]
      },
      {
        test: /\.css$/i,
        use: [
          MiniCssExtractPlugin.loader,
          "css-loader", "postcss-loader",
        ]
      },
      {
        test: /\.(js|jsx)$/,
        exclude: [/node_modules/],
        use: {
          loader: 'babel-loader',
          options: {
            
            presets: ['@babel/preset-env', ["@babel/preset-react", {
              "runtime": "automatic"
            }]]
            
          }
        }
      },
      
        {
          test: /\.(ts|tsx)$/,
          exclude: /node_modules/,
          use: 'ts-loader',
        },
        
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "styles.css",
      chunkFilename: "styles.css"
    }),
    new HtmlWebpackPlugin({
      title: 'geotabDriveScratchie',
      filename: `geotabDriveScratchie.html`,
      template: 'src/app/geotabDriveScratchie.html',
      inject: 'body'
    }),
    new CopyWebpackPlugin({
      patterns: [
        { from: './src/app/images/icon.svg', to: 'images/' },
        {
          from: './src/config.json',
          transform: transform,
          to: 'configuration.json'
        },
      ]
    })
  ]
}```


## File: ./webpack.dev.js

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  mode: 'development',
  entry: {
    bundle: path.resolve(__dirname, 'src/.dev/index.js'),
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name]-[contenthash].js',
    assetModuleFilename: '[name][ext]',
    clean: true
  },
  devServer: {
    static: {
      directory: path.resolve(__dirname, 'dist')
    },
    port: 3000,
    open: true,
    hot: true,
    compress: true,
    historyApiFallback: true
  },
  devtool: 'source-map',
  
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
  },
  
  module: {
    rules: [
      {
        test: /\.scss$/i,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader'
        ]
      },
      {
        test: /\.css$/i,
        use: [
          MiniCssExtractPlugin.loader,
          "css-loader", "postcss-loader",
        ]
      },
      {
        test: /\.(js|jsx)$/,
        exclude: [/node_modules/],
        use: {
          loader: 'babel-loader',
          options: {
            
            presets: ['@babel/preset-env', ["@babel/preset-react", {
              "runtime": "automatic"
            }]]
            
          }
        }
      },
      
      {
        test: /\.(ts|tsx)$/,
        exclude: /node_modules/,
        use: 'ts-loader',
      },
      
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: "styles.css",
      chunkFilename: "styles.css"
    }),
    new HtmlWebpackPlugin({
      title: 'geotabDriveScratchie',
      filename: 'index.html',
      template: 'src/app/geotabDriveScratchie.html',
      inject: 'body'
    }),
    new HtmlWebpackPlugin({  // Also generate a test.html
      filename: 'style-guide.html',
      template: 'src/.dev/styles/styleGuideMyGeotab.html',
      inject: false
    })
  ]
}```


## File: ./components/RiskChart.js

```js
// components/RiskChart.js
import { Line } from "react-chartjs-2";
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend } from "chart.js";
import { useMemo } from "react";

// Register Chart.js components
ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

export default function RiskChart({ driverName, riskData }) {
  // Simulate historical trend data for each risk factor (e.g., 6 periods)
  const chartData = useMemo(() => {
    const labels = ["-5m", "-4m", "-3m", "-2m", "-1m", "Current"];  // last 5 months and current
    // Helper to generate a semi-random sequence based on current value or placeholder if null
    const genSeries = (currentVal, seed) => {
      const series = [];
      const base = currentVal ?? (seed % 5 + 1) * 20; // if no current value, use seed to pick a base 20-100
      for (let i = 0; i < labels.length; i++) {
        // simulate variation over time
        let variance = Math.floor(Math.random() * 15) - 7; // random between -7 and +7
        let val = Math.max(0, Math.min(100, base + variance * i));
        series.push(val);
      }
      return series;
    };
    // Use driverName (or id) as a seed for consistent random generation
    const seed = driverName.split("").reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
    const speedingSeries = genSeries(riskData.speeding, seed);
    const accelSeries = genSeries(riskData.acceleration, seed + 1);
    const brakingSeries = genSeries(riskData.braking, seed + 2);
    const corneringSeries = genSeries(riskData.cornering, seed + 3);

    return {
      labels,
      datasets: [
        { label: "Speeding", data: speedingSeries, borderColor: "#e74c3c", backgroundColor: "#e74c3c88" },
        { label: "Acceleration", data: accelSeries, borderColor: "#f39c12", backgroundColor: "#f39c1288" },
        { label: "Braking", data: brakingSeries, borderColor: "#3498db", backgroundColor: "#3498db88" },
        { label: "Cornering", data: corneringSeries, borderColor: "#8e44ad", backgroundColor: "#8e44ad88" }
      ]
    };
  }, [driverName, riskData]);

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: { legend: { position: "bottom" }, title: { display: false } },
    scales: {
      y: { beginAtZero: true, max: 100 }
    }
  };

  return (
    <div style={{ height: "200px" }}>
      <Line data={chartData} options={options} />
    </div>
  );
}```


## File: ./components/DriverTable.js

```js
// components/DriverTable.js
import { useState } from "react";
import RiskChart from "./RiskChart";
import { Button, Table, TableHead, TableRow, TableCell, TableBody, Badge } from "zenith-ui";

export default function DriverTable({ drivers }) {
  const [expandedDriverId, setExpandedDriverId] = useState(null);
  const [awardingId, setAwardingId] = useState(null);  // track driver being awarded to disable button while sending

  const handleAward = async (driverId) => {
    setAwardingId(driverId);
    try {
      const res = await fetch("/api/scratchie", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ driverId })
      });
      if (!res.ok) {
        const data = await res.json();
        alert(data.error || "Failed to award Scratchie");
      } else {
        alert("ðŸŽ‰ Scratchie awarded to driver!");
      }
    } catch (err) {
      console.error("Scratchie award error:", err);
      alert("Error awarding Scratchie.");
    } finally {
      setAwardingId(null);
    }
  };

  const toggleExpand = (driverId) => {
    setExpandedDriverId(prev => (prev === driverId ? null : driverId));
  };

  return (
    <Table aria-label="Driver Performance">
      <TableHead>
        <TableRow>
          <TableCell>Driver</TableCell>
          <TableCell>Speeding</TableCell>
          <TableCell>Acceleration</TableCell>
          <TableCell>Braking</TableCell>
          <TableCell>Cornering</TableCell>
          <TableCell align="center">Actions</TableCell>
        </TableRow>
      </TableHead>
      <TableBody>
        {drivers.map(driver => {
          // Determine display values or badges for risk ratings
          const { speeding, acceleration, braking, cornering } = driver.risk;
          // For simplicity, display risk as a number or "N/A" if null.
          // Could also use colored Badges to indicate risk level (e.g., green/yellow/red).
          const formatRisk = (val) => val === null ? "N/A" : val;
          return (
            <Fragment key={driver.id}>
              {/* Driver row */}
              <TableRow>
                <TableCell>{driver.name}</TableCell>
                <TableCell>{formatRisk(speeding)}</TableCell>
                <TableCell>{formatRisk(acceleration)}</TableCell>
                <TableCell>{formatRisk(braking)}</TableCell>
                <TableCell>{formatRisk(cornering)}</TableCell>
                <TableCell align="center" style={{ whiteSpace: "nowrap" }}>
                  <Button 
                    appearance="secondary" 
                    size="small" 
                    onClick={() => toggleExpand(driver.id)}
                    style={{ marginRight: "0.5rem" }}
                  >
                    {expandedDriverId === driver.id ? "Hide Trend" : "View Trend"}
                  </Button>
                  <Button 
                    appearance="primary" 
                    size="small" 
                    onClick={() => handleAward(driver.id)} 
                    disabled={awardingId === driver.id}
                  >
                    {awardingId === driver.id ? "Awarding..." : "Award Scratchie"}
                  </Button>
                </TableCell>
              </TableRow>
              {/* Expandable row for chart */}
              {expandedDriverId === driver.id && (
                <TableRow>
                  <TableCell colSpan={6} style={{ background: "#f9f9f9" }}>
                    <div style={{ padding: "1rem 0" }}>
                      <RiskChart driverName={driver.name} riskData={driver.risk} />
                    </div>
                  </TableCell>
                </TableRow>
              )}
            </Fragment>
          );
        })}
      </TableBody>
    </Table>
  );
}```


## File: ./lib/geotab.js

```js
// lib/geotab.js
const fetch = require('node-fetch');  // (if using Node fetch; in Next API routes, the global fetch is available)

const GEOTAB_API_BASE = process.env.GEOTAB_SERVER || "my.geotab.com";
/** 
 * Cache for driver data to minimize API calls.
 * cachedDrivers.data will store the latest driver list with risk metrics,
 * cachedDrivers.timestamp tracks the last refresh time.
 */
let cachedDrivers = {
  data: null,
  timestamp: 0
};
const CACHE_TTL_MS = 12 * 60 * 60 * 1000;  // refresh every 12 hours (43200000 ms)

/**
 * Make a JSON-RPC call to the Geotab API.
 * @param {string} server - The Geotab server domain (e.g. "my.geotab.com" or "my3.geotab.com").
 * @param {string} method - API method name (e.g. "Authenticate", "Get").
 * @param {Object} params - Parameters for the API call (will include credentials as needed).
 * @returns {Promise<any>} - Resolves with the result of the API call.
 */
async function geotabApiCall(server, method, params) {
  const url = `https://${server}/apiv1`;  // Geotab JSON-RPC endpoint
  const body = {
    method,
    params,
    id: 1,
    jsonrpc: "2.0"
  };
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  const json = await res.json();
  if (json.error) {
    // Throw an error with message if API returned an error
    const msg = json.error.message || "Geotab API error";
    throw new Error(msg);
  }
  return json.result;
}

/**
 * Authenticate with Geotab to obtain a session credential.
 * @param {string} username - Geotab username (email).
 * @param {string} password - Geotab password.
 * @param {string} database - Geotab database name.
 * @returns {Promise<{ server: string, credentials: object }>}
 *    server: the server domain to use for subsequent calls,
 *    credentials: object containing at least { userName, sessionId, database }.
 */
async function authenticateGeotab(username, password, database) {
  // Initial authentication call to the base server (e.g., my.geotab.com).
  const loginParams = { userName: username, password: password, database: database };
  const loginResult = await geotabApiCall(GEOTAB_API_BASE, "Authenticate", loginParams);
  // Determine the server to use: if loginResult.path is "ThisServer", remain on GEOTAB_API_BASE, otherwise use the provided path.
  let server = GEOTAB_API_BASE;
  if (loginResult.path && loginResult.path !== "ThisServer") {
    server = loginResult.path;
  }
  const credentials = loginResult.credentials;  // { userName, sessionId, database }
  return { server, credentials };
}

/**
 * Fetch the list of drivers (users with isDriver=true) and their risk metrics.
 * Uses caching to avoid frequent calls â€“ updates once or twice daily.
 * @param {object} credentials - Geotab credentials object with sessionId, userName, database.
 * @param {string} server - Geotab server domain to call (from authentication).
 */
async function getDriverData(credentials, server) {
  const now = Date.now();
  // Return cached data if it exists and is still fresh
  if (cachedDrivers.data && (now - cachedDrivers.timestamp) < CACHE_TTL_MS) {
    return cachedDrivers.data;
  }
  // Otherwise, fetch from Geotab API
  const params = {
    typeName: "User",
    search: { isDriver: true, activeFrom: { "--gt": 0 } },  // isDriver = true (and activeFrom > 0 filters active users)
    credentials
  };
  const drivers = await geotabApiCall(server, "Get", params);
  // Attach risk rating data if available (here we assume no direct fields, so this could be extended if an API existed for risk metrics)
  // For now, just include placeholder or default values for risk categories if none present:
  const driversWithRisk = drivers.map(d => {
    return {
      id: d.id,
      name: d.name || d.firstName + " " + d.lastName || d.userName,
      companyGroups: d.companyGroups,  // group membership if needed
      // Risk ratings if provided by some data source, else null (we'll handle display of "N/A" on frontend if null)
      risk: {
        speeding: d.speedingRisk ?? null,
        acceleration: d.accelerationRisk ?? null,
        braking: d.brakingRisk ?? null,
        cornering: d.corneringRisk ?? null
      }
    };
  });
  // Update cache
  cachedDrivers.data = driversWithRisk;
  cachedDrivers.timestamp = now;
  return driversWithRisk;
}

module.exports = { authenticateGeotab, getDriverData };```


## File: ./api.js

```js
// api.js
export async function fetchDrivers(api) {
    // Get all users marked as drivers
    const drivers = await api.call("Get", { 
      typeName: "User", 
      search: { isDriver: true, active: true } 
    });
    return drivers;
  }```


## File: ./pages/index.js

```js
// pages/index.js
import { useState } from "react";
import { useRouter } from "next/router";
// Import Zenith UI components
import { Button, TextField, Card, CardContent, Heading } from "zenith-ui";

export default function LoginPage({}) {
  const router = useRouter();
  const [database, setDatabase] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ database, username, password })
      });
      setLoading(false);
      if (res.ok) {
        // Logged in successfully â€“ redirect to dashboard
        router.push("/dashboard");
      } else {
        const data = await res.json();
        setError(data.error || "Login failed");
      }
    } catch (err) {
      console.error("Login error:", err);
      setLoading(false);
      setError("Network error, please try again");
    }
  };

  return (
    <div style={{ maxWidth: "400px", margin: "100px auto", textAlign: "center" }}>
      <Card>
        <CardContent>
          <Heading level={3}>Geotab Driver Dashboard Login</Heading>
          <form onSubmit={handleSubmit}>
            <TextField 
              label="Database" 
              placeholder="Database name" 
              value={database} 
              onChange={e => setDatabase(e.target.value)} 
              required 
              style={{ marginBottom: "1rem" }}
            />
            <TextField 
              label="Username" 
              placeholder="Email or username" 
              value={username} 
              onChange={e => setUsername(e.target.value)} 
              required 
              style={{ marginBottom: "1rem" }}
            />
            <TextField 
              type="password" 
              label="Password" 
              placeholder="Password" 
              value={password} 
              onChange={e => setPassword(e.target.value)} 
              required 
              style={{ marginBottom: "1rem" }}
            />
            {error && <div style={{ color: "red", marginBottom: "1rem" }}>{error}</div>}
            <Button type="submit" appearance="primary" disabled={loading}>
              {loading ? "Logging in..." : "Login"}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

// Note: We could add getServerSideProps here to redirect if already logged in (session cookie present).```


## File: ./pages/api/scratchie.js

```js
// pages/api/scratchie.js
import cookie from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).send("Method Not Allowed");
  }
  // (Optional) verify user is authenticated via Geotab session cookie
  const cookies = cookie.parse(req.headers.cookie || "");
  if (!cookies.geotabSession) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  const { driverId } = req.body || {};
  if (!driverId) {
    return res.status(400).json({ error: "Missing driverId" });
  }
  // Prepare Scratchie API request
  const SCRATCHIE_URL = process.env.SCRATCHIE_API_URL;
  const SCRATCHIE_KEY = process.env.SCRATCHIE_API_KEY;
  if (!SCRATCHIE_URL || !SCRATCHIE_KEY) {
    console.error("Scratchie API credentials not configured");
    return res.status(500).json({ error: "Scratchie integration not configured" });
  }

  try {
    // Call the Scratchie API to award a reward to the driver
    const resp = await fetch(SCRATCHIE_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SCRATCHIE_KEY}`
      },
      body: JSON.stringify({ driverId: driverId })
    });
    if (!resp.ok) {
      throw new Error(`Scratchie API responded with status ${resp.status}`);
    }
    // Assuming the Scratchie API returns JSON
    const data = await resp.json();
    return res.status(200).json({ success: true, detail: data });
  } catch (err) {
    console.error("Failed to award scratchie:", err);
    return res.status(500).json({ error: "Scratchie API call failed" });
  }
}```


## File: ./pages/api/drivers.js

```js
// pages/api/drivers.js
import { getDriverData } from "../../lib/geotab";
import cookie from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).send("Method Not Allowed");
  }
  // Parse the geotabSession cookie
  const cookies = cookie.parse(req.headers.cookie || "");
  const sessionCookie = cookies.geotabSession;
  if (!sessionCookie) {
    return res.status(401).json({ error: "Not authenticated" });
  }
  let session;
  try {
    session = JSON.parse(sessionCookie);
  } catch {
    return res.status(400).json({ error: "Invalid session cookie" });
  }
  const { sessionId, userName, database, server } = session;
  if (!sessionId || !userName || !database || !server) {
    return res.status(401).json({ error: "Invalid session credentials" });
  }

  try {
    // Prepare credentials object for Geotab API call
    const credentials = { sessionId, userName, database };
    // Fetch driver data (using caching to reduce API calls)
    const drivers = await getDriverData(credentials, server);
    res.status(200).json(drivers);
  } catch (err) {
    console.error("Error fetching drivers:", err);
    // If session is expired or invalid, return 401 to force re-login
    return res.status(401).json({ error: "Failed to retrieve driver data" });
  }
}```


## File: ./pages/api/login.js

```js
// pages/api/login.js
import { authenticateGeotab } from "../../lib/geotab";
import cookie from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).send("Method Not Allowed");
  }
  const { username, password, database } = req.body || {};
  // Allow fallback to environment credentials (for development or service account login)
  const user = username || process.env.GEOTAB_USERNAME;
  const pass = password || process.env.GEOTAB_PASSWORD;
  const db = database || process.env.GEOTAB_DATABASE;
  if (!user || !pass || !db) {
    return res.status(400).json({ error: "Missing credentials" });
  }

  try {
    // Authenticate with Geotab API
    const { server, credentials } = await authenticateGeotab(user, pass, db);
    // Store session info (sessionId, userName, database, and server) in a secure, HttpOnly cookie
    const sessionData = {
      sessionId: credentials.sessionId,
      userName: credentials.userName,
      database: credentials.database,
      server: server
    };
    // Serialize cookie (HttpOnly, not accessible via JS, secure in production)
    res.setHeader("Set-Cookie", cookie.serialize("geotabSession", JSON.stringify(sessionData), {
      httpOnly: true,
      secure: true,
      sameSite: "lax",
      path: "/"      // cookie valid for all routes
    }));
    return res.status(200).json({ success: true });
  } catch (err) {
    console.error("Geotab login failed:", err);
    return res.status(401).json({ error: "Invalid Geotab credentials" });
  }
}```


## File: ./pages/dashboard.js

```js
// pages/dashboard.js
import { useEffect, useState } from "react";
import { useRouter } from "next/router";
import DriverTable from "../components/DriverTable";
import { Spinner, Heading } from "zenith-ui";

export default function DashboardPage() {
  const router = useRouter();
  const [drivers, setDrivers] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    // Fetch driver performance data from our API
    async function fetchDrivers() {
      try {
        const res = await fetch("/api/drivers");
        if (res.status === 401) {
          // Session invalid or expired â€“ redirect to login
          router.replace("/");
          return;
        }
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data.error || "Failed to load driver data");
        }
        setDrivers(data);
      } catch (err) {
        console.error("Error loading drivers:", err);
        setError("Unable to load driver data.");
      } finally {
        setLoading(false);
      }
    }
    fetchDrivers();
  }, [router]);

  if (loading) {
    return (
      <div style={{ textAlign: "center", marginTop: "5rem" }}>
        <Spinner size="large" label="Loading driver data..." />
      </div>
    );
  }

  if (error) {
    return <div style={{ color: "red", textAlign: "center", marginTop: "2rem" }}>{error}</div>;
  }

  return (
    <div style={{ padding: "1rem" }}>
      <Heading level={3} style={{ marginBottom: "1rem" }}>
        Driver Performance Dashboard
      </Heading>
      {drivers && <DriverTable drivers={drivers} />}
    </div>
  );
}```


## File: ./src/app/index.js

```js
/**
 * This is the entry point for your app
 * Include any assets to be bundled in here
 * (css/images/js/etc)
 */

// Allowing babel to work with older versions of IE
const regeneratorRuntime = require('regenerator-runtime');

if(!geotab.addin.geotabDriveScratchie){
    
    require('./scripts/main');
    
}

require('./styles/main.css');
```


## File: ./src/app/styles/app.css

```css
.zda-app {
    height: calc(100% - 52px);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.zda-app__header {
    flex: 0 0 auto;
}

.zda-app__content {
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
}

.zda-app__sections {
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
    gap: 16px;
    background-color: var(--backgrounds-content-0);
}

.zda-section {
    background-color: var(--backgrounds-main);
}

.zda-section__header {
    color: var(--text-secondary);
    padding: 10px 12px;
    margin: 0;
}

.zda-section__content {
    color: var(--text-primary);
    padding: 12px;
    margin: 0;
    min-height: 160px;
}

@media screen and (max-width: 640px) {
    .za-table-container {
        padding: 8px 12px;
    }
}```


## File: ./src/app/styles/index.css

```css
.zenith-addin {
    box-sizing: border-box;
    height: 100%;
    /* overflow: hidden; */
}
```


## File: ./src/app/styles/main.css

```css
.hidden {
    display: none!important;
}```


## File: ./src/app/scripts/contexts/addinContext.ts

```ts
import React from "react";

export interface IGeotabToken {
    rememberMe?: boolean;
    date?: Date;
    source?: string;
    target?: string;
    database: string;
    userName: string;
    sessionId: string;
}

interface IOutputIdEntity {
    groupId: string;
}

const enum RelationOperator {
    "AND" = "And",
    "OR" = "Or"
}

export interface ISessionInfo {
    database: string;
    userName: string;
    sessionId: string;
    domain: string;
}

export interface IGroupListStateOutput<T extends IOutputIdEntity = IOutputIdEntity> {
    relation: RelationOperator;
    groupListSearches: (T | IGroupListStateOutput<T>)[];
}

type TReportGAEvent = (eventAction: string, eventParams: { [key: string]: string }) => void;

export type TCallParams = [string, any?];
export type TMulticallParam = [string, object];
export type TCall = <T = any>(method: string, params: any, successCallback?: Function, errorCallback?: Function) => Promise<T>;
export type TMulticall = <T = any>(calls: TCallParams[]) => Promise<T[]>;
export type TGetSessionCallback = (successCallback: (token: IGeotabToken, host: string) => any, newSession?: boolean) => void;

interface IIdEntity {
    id: string;
}

export interface IGeotabPage {
    getState: () => any;
    setState: (newState: any) => void;
    gotoPage: (pageName: string, options: any) => boolean;
    hasAccessToPage: (pageName: string) => boolean;
    getGroupFilter: () => IIdEntity[];
    getAdvancedGroupFilter: () => IGroupListStateOutput;
    translate: (arg: string | HTMLElement) => string | HTMLElement;
    createGtag: (gaMeasurementId: string) => TReportGAEvent;
    pageState: any;
}


export interface IGeotabApi {
    call: TCall;
    multiCall: TMulticall;
    forget?: () => void;
    getSession(): Promise<ISessionInfo>;
}

interface ILocalizer {}
interface IUser {
    id: string;
    name: string;
    firstName?: string;
}

export interface IAddinContext {
    geoApi: IGeotabApi;
    pageApi: IGeotabPage;
    currentUser: IUser;
    localizer: ILocalizer;
    addinElement: HTMLElement;
    userAddInSecurityIdentifiers: string[];
    addAddinListener: (event: "focus" | "blur", callback: () => void) => () => void;
}

const addinContext = React.createContext<IAddinContext>(undefined as any);

export { addinContext as AddinContext };```


## File: ./src/app/scripts/utils/logger.js

```js
/* eslint-disable no-console */
const titleStyle = 'background: #222; color: lime; font: bold 1.2em "Fira Sans", serif; padding: 0.2em';
const separatorStyle = 'background: #222; color: yellow; font: bold 1.2em "Fira Sans", serif; padding: 0.2em';
const messageStyle = 'background: #222; color: cyan; font: italic 1.2em "Fira Sans", serif; padding: 0.2em';

// const url = new URL(import.meta.url);
// const addinName = url.searchParams.get('appName') != null
// ? url.searchParams.get('appName') : 'ADDIN';

const logger = (addinName) => (
  {
    log: (message) => {
      if (typeof message !== 'object') {
        console.log(`%c${addinName}%c ~~~ %c${message}`, titleStyle, separatorStyle, messageStyle);
      } else {
        const separator = addinName.replaceAll(/./ig, '#');

        console.log(`%c### ${addinName} ###`, titleStyle);
        console.log('%c%o', messageStyle, message);
        console.log(`%c###${separator}####`, titleStyle);
      }
    },
    warn: (message) => {
      if (typeof message !== 'object') {
        console.warn(`%c${addinName}%c ~~~ %c${message}`, titleStyle, separatorStyle, messageStyle);
      } else {
        const separator = addinName.replaceAll(/./ig, '#');

        console.warn(`%c### ${addinName} ###`, titleStyle);
        console.warn('%c%o', messageStyle, message);
        console.warn(`%c###${separator}####`, titleStyle);
      }
    },
    error: (message) => {
      if (typeof message !== 'object') {
        console.error(`%c${addinName}%c ~~~ %c${message}`, titleStyle, separatorStyle, messageStyle);
      } else {
        const separator = addinName.replaceAll(/./ig, '#');

        console.error(`%c### ${addinName} ###`, titleStyle);
        console.error('%c%o', messageStyle, message);
        console.error(`%c###${separator}####`, titleStyle);
      }
    },
  }
);

export default logger;
```


## File: ./src/app/scripts/main.js

```js
/* eslint-disable */
import React from "react";
import { createRoot } from 'react-dom/client';
import { AddinContext, IGeotabApi, IGeotabPage } from "./contexts/addinContext";
import App from './components/App'
import "../styles/index.css";

/**
 * @returns {{initialize: Function, focus: Function, blur: Function, startup; Function, shutdown: Function}}
 */
geotab.addin.geotabDriveScratchie = function (api, state, meta) {
  'use strict';
  const appName = 'geotabDriveScratchie';
  const addinId = 'aWU2YjJmZmItNGU0ZC04ZjZ';
  let reactRoot;
  
  // the root container
  
  var elAddin = document.getElementById('geotabDriveScratchie-app');
  
  function startAddIn() {
    function initializeReactApp() {
      try {
        reactRoot.render(
          <React.StrictMode>
            <AddinContext.Provider
              value={{
                geoApi: api,
                pageApi: state,
                currentUser: null,
                localizer: {},
                addinElement: elAddin,
                userAddInSecurityIdentifiers: [],
                addAddinListener: () => () => { }
              }}
            >
              <App />
            </AddinContext.Provider>
          </React.StrictMode>
        );
      } catch (e) {
        console.log(e);
        alert(e);
      }
    }

    initializeReactApp();
  }
  
  return {
    
    /**
     * Startup Add-Ins are executed when a driver logs in to the Drive App for the first time. 
     * When the dashboard page is visible, the startup method is only called once. 
     * If the user navigates away from the page then navigates back, the startup method is not called again.
     * If the Add-In requires re-initialization, the user must either log out and log in again, or refresh the application.
     * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.
     * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.
     * @param {function} initializeCallback - Call this when your initialize route is complete. Since your initialize routine
     *        might be doing asynchronous operations, you must call this method when the Add-In is ready
     *        for display to the user.
    */
    startup: function (freshApi, freshState, initializeCallback) {
        // MUST call initializeCallback when done any setup
          initializeCallback();
    },
    
    /**
     * initialize() is called only once when the Add-In is first loaded. Use this function to initialize the
     * Add-In's state such as default values or make API requests (MyGeotab or external) to ensure interface
     * is ready for the user.
     * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.
     * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.
     * @param {function} initializeCallback - Call this when your initialize route is complete. Since your initialize routine
     *        might be doing asynchronous operations, you must call this method when the Add-In is ready
     *        for display to the user.
     */
    initialize: function (freshApi, freshState, initializeCallback) {
      // Loading translations if available
      if (freshState.translate) {
        freshState.translate(elAddin || '');
      }
        reactRoot = createRoot(elAddin);
      // MUST call initializeCallback when done any setup
        initializeCallback();
    },

    /**
     * focus() is called whenever the Add-In receives focus.
     *
     * The first time the user clicks on the Add-In menu, initialize() will be called and when completed, focus().
     * focus() will be called again when the Add-In is revisited. Note that focus() will also be called whenever
     * the global state of the MyGeotab application changes, for example, if the user changes the global group
     * filter in the UI.
     *
     * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.
     * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.
    */
    focus: function (freshApi, freshState) {
        elAddin.className = elAddin.className.replace('hidden', '').trim();
        startAddIn(elAddin, reactRoot)
    },

    /**
     * blur() is called whenever the user navigates away from the Add-In.
     *
     * Use this function to save the page state or commit changes to a data store or release memory.
     *
     * @param {object} freshApi - The GeotabApi object for making calls to MyGeotab.
     * @param {object} freshState - The page state object allows access to URL, page navigation and global group filter.
    */
    blur: function () {
      
    },
      /**
       * Shutdown Add-Ins are executed when the final driver logs out of the Drive App.
       * If there are co-drivers, and one of the co-drivers logs out (while other drivers remain logged in to the Drive App),
       * the shutdown Add-In is not executed.
       * Additionally, the Add-In is expected to return a promise since shutdown Add-Ins have a 15-second time limit
       * to perform their function before the Add-Ins time out and the logout process is completed.
       * The time limit prevents the application from freezing in the middle of the logout process as a result of faulty Add-Ins.
       * @param {object} api - The GeotabApi object for making calls to MyGeotab.
       * @param {object} state - The page state object allows access to URL, page navigation and global group filter.
       * @param {function} resolve - call this somewhere so the promise resolves
      */
      shutdown: function (api, state, callback) {
          return new Promise (resolve => {
            // Do work, make any api calls etc

            resolve(); // eventually need to call this somewhere so the promise resolves
          });
      }
  };
};
```


## File: ./src/app/scripts/components/App.tsx

```tsx
import React, { useCallback, useMemo, useState } from "react";
import "@geotab/zenith/dist/index.css";
import "../../styles/app.css";
import {
    Button,
    FooterButtons,
    Header,
    IconQuestion,
    Menu,
    Modal,
    Tabs,
} from "@geotab/zenith";
import { Tab1Content } from "./Tab1Content";
import { Tab2Content } from "./Tab2Content";

const App: React.FC = () => {
    const [isHelpVisible, setHelpVisible] = useState(false);
    const [activeTab, setActiveTab] = useState("tab1");
    const tabs = useMemo(() => [{
        id: "tab1",
        name: "Tab 1"
    }, {
        id: "tab2",
        name: "Tab 2"
    }], []);

    const content = useMemo(() => ({
        "tab1": <Tab1Content />,
        "tab2": <Tab2Content />
    }), []);

    const contactSupport = useCallback(() => {
        console.log("Contact support");
        setHelpVisible(false);
    }, []);

    return <div className="zda-app">
        <Header className="zda-app__header">
            <Header.Title pageName="Add-in title" />
            <Header.Button id="about" type="tertiary" icon={IconQuestion} onClick={() => setHelpVisible(true)}></Header.Button>
            <Header.Menu id="submenu" type="tertiary" name="More">
                <Menu.Item id="settings" name="Settings" onClick={() => { console.log("Settings"); }} />
                <Menu.Item id="action1" name="Action 1" onClick={() => { console.log("Action 1"); }} />
                <Menu.Item id="action2" name="Action 2" onClick={() => { console.log("Action 2"); }} />
                <Menu.Item id="action3" name="Action 3" onClick={() => { console.log("Action 3"); }} />
            </Header.Menu>
            <Tabs key="headerTabs" tabs={tabs} activeTabId={activeTab} onTabChange={setActiveTab} />
        </Header>

        <div className="zda-app__content">
           { content[activeTab as ("tab1" | "tab2")] || null }
        </div>
        <FooterButtons isSticky={true}>
            <Button type="primary">Main action</Button>
        </FooterButtons>

        { isHelpVisible
            ? <Modal type="info" isOpen={true} onClose={() => setHelpVisible(false)} title="About this add-in">
                    Lorem ipsum dolor sit amet consectetur. Quis consectetur suspendisse nullam magn eget eu facilisi. Mollis eleifend et et commodo consectetur lorem sit et.
                    <Modal.TertiaryButton onClick={ contactSupport }>Contact support</Modal.TertiaryButton>
                </Modal>
            : null }
    </div>
};

export default App;
```


## File: ./src/app/scripts/components/Tab1Content.tsx

```tsx
import React from "react";
import { Banner } from "@geotab/zenith";

export const Tab1Content = () => {
    return <>
        <Banner type="warning" size="XL" icon={true}>Banner text</Banner>
        <div className="zda-app__sections">
            <section className="zda-section">
                <h3 className="zda-section__header heading-02-mobile-drive">Section heading</h3>
                <p className="zda-section__content body-02-short-mobile-drive">Section content</p>
            </section>

            <section className="zda-section">
                <h3 className="zda-section__header heading-02-mobile-drive">Section heading</h3>
                <p className="zda-section__content body-02-short-mobile-drive">Section content</p>
            </section>

            <section className="zda-section">
                <h3 className="zda-section__header heading-02-mobile-drive">Section heading</h3>
                <p className="zda-section__content body-02-short-mobile-drive">Section content</p>
            </section>
        </div>
    </>;
};```


## File: ./src/app/scripts/components/Tab2Content.tsx

```tsx
import React from "react";

export const Tab2Content = () => {
    return <>
        <div className="zda-app__sections">
            <section className="zda-section">
                <h3 className="zda-section__header heading-02-mobile-drive">Section heading</h3>
                <p className="zda-section__content body-02-short-mobile-drive">Tab 2</p>
            </section>
        </div>
    </>;
};```


## File: ./src/app/geotabDriveScratchie.html

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>geotab-drive-scratchie</title>
</head>

<body>

  <div id="geotabDriveScratchie-app" class="hidden">
    
      <div id="geotabDriveScratchie" style="overflow: auto; height: 100%;font-size: 14px;">
        <div class="panel">
          <h2 class="panel__title">geotabDriveScratchie</h2>
          <p>Driver: <span id="geotabDriveScratchie-driver"></span></p>
          <p>Vehicle: <span id="geotabDriveScratchie-vehicle"></span></p>
        </div>
      </div>
    
  </div>

</body>

</html>```


## File: ./src/.dev/navbar/NavFactory.js

```js
/**
 * Factory Build for the nav bar
 * 
 * Returns components of the navbar list
 */
class NavFactory {
   
    constructor(language){
        this.language = language;
    }

    /**
     * Assembles the beginning of a header tag that can contain a sub menu
     * @param {object} props item in the props list 
     */
    openMainHeader(props){
        let mainHead = new OpenMainHeader(props, this.language);
        return mainHead.returnHTML();
    }

    closeMainHeader(){
        return `</li>`;
    }

    /**
     *  Assembles the beginning of a sub menu that is hidden until the header option is clicked
     * @param {object} props item in the props list 
     */
    openSubMenu(props){
        let subMenu = new OpenSubMenu(props);
        return subMenu.returnHTML();
    }

    closeSubMenu(){
        return `</ul></div>`;
    }

    /**
     * Creates a complete subheader block
     * @param {object} props subheader object in the props list 
     */
    subHeader(props){
        let subHead = new SubHeader(props, this.language);
        return subHead.returnHTML();
    }
}

class OpenMainHeader {
    constructor(props, language){
        let title = props.labelText[language] ? props.labelText[language] : props.labelText["en"];
        // Buttons don't change the title ref -> What is used to base the blur() functions on
        this.html = `
        <li class="mainMenuHeader">
            ${props.hasSubmenu ? 
            `<button id="btn-${props.name}" class="mainMenuHeaderLink mainMenuLink ellipsis popupWindowTrigger">
                <span class="icon geotabIcons_${props.name}"></span>
                <span class="itemText">${title}</span>
            </button>`
                :
            `<a href="#${props.name}" id="btn-${props.name}" class="mainMenuHeaderLink mainMenuLink ellipsis popupWindowTrigger">
                <span class="icon geotabIcons_${props.name}"></span>
                <span class="itemText">${title}</span>
            </a>`
            }
        `.trim();
    }

    returnHTML(){
        return this.html;
    }
}

class OpenSubMenu {
    constructor(props){
        this.html =`
        <div id="submenu-${props.id}" class="mainMenuHeaderSubMenu">
            <ul id="${props.id}" class="mainMenuSubMenu">
        `.trim();
    }

    returnHTML(){
        return this.html;
    }
}

class SubHeader {
    constructor(props, language){
        let title = props.labelText[language] ? props.labelText[language] : props.labelText["en"];
        this.html = `
        <li class="mainMenuOption">
            <a class="mainMenuLink" title="The Product Guide provides an introduction to the application and its features." href="#${props.name}">
                <span class="icon geotabIcons_${props.name}"></span>
                <div class="ellipsis">${title}</div>
            </a>
        </li>`.trim();
    }

    returnHTML(){
        return this.html;
    }
}

module.exports = NavFactory;```


## File: ./src/.dev/navbar/navbar.js

```js
let body = document.getElementsByTagName('body')[0];
let navbar = `
<nav id="menuId" class="westPane shadowedRight animated" style="top: 40px;">
    <div class="mainMenuSearchBar">
        <div class="mainMenuSearch">
            <button id="menuToggle" class="mainMenuSearchButton">
                <svg class="svgIcon geotabIcons_chevron" style="height: 30px; width: 30px;"></svg>
            </button>
            <div class="mainMenuSearchLogo">
                <div class="mainMenuCompanyLogo"></div>
            </div>
        </div>
    </div>
    <div id="navigationContainer">
        <div id="navigationId" class="shadowedRight scrollHost touchScrollClass hardwareAccelerationClass" tabindex="-1">
            <ul id="navBase" class="mainMenu" role="menu">
            </ul>
        </div>
    </div>
    <div id="hiddenMenu" class="mainMenu mainMenuPopup">
        <ul class="mainMenuSubMenu">
            <li class="mainMenuOption">
                <a class ="mainMenuLink" href="#"></a>
            </li>
        </ul>
    </div>
</nav>`.trim();

body.innerHTML = navbar + body.innerHTML;```


## File: ./src/.dev/navbar/NavHandler.js

```js
class NavHandler {
    
    /**
    * Params handed in from login.js. Allows use of focus and blur from navbar
    * interactions
    * 
    * @param {object} api - GeotabAPI object
    * @param {object} state - mock addin state - Contains addin controls (blur, etc.)
    */
    constructor(navFact, props){
        this.navFact = navFact;
        this.props = props;
        this.focus = true;
    }

    /**
    * Assigns and handles behaviour of the navbar when clicked
    * 
    * @param {event} event click event for the click
    * @param {object} self DOM Element making the click
    * @param {HTMLCollection} menuHeaders The headers of the nav bar
    * @param {object} floatingMenu DOM Element for the floating menu bar - appears when navbar is collapsed
    * @param {bool} navigationBarExtended
    * @param {bool} submenu if the item being clicked has a submenu or not -> Changes the way the headers behave
    */
    clickHandler(event, self, menuHeaders, floatingMenu, navigationBarExtended, submenu=false){
        // Add active state to clicked nav button if not already selected
        if(!self.className.includes('activeStateButton')){
            self.className = self.className += ' activeStateButton';
        }
    
        let parent = self.parentElement;
        // Handling submenu expansion
        if(navigationBarExtended){ 
            if(parent.className.includes(' mainMenuHeaderExpanded')){
                parent.className = parent.className.replace(' mainMenuHeaderExpanded', '');
            } else {
                parent.className = parent.className += ' mainMenuHeaderExpanded';
            }
        } else {// Showing the floating bar if it is not visible
            // Ensuring the header has a submenu -> parent.children[1] is an associated submenu
            if(parent.children[1] !== undefined){
                // Making the floating menu a duplicate of the submenu associated with the header
                floatingMenu.innerHTML = parent.children[1].innerHTML;
                if(floatingMenu.style.display == 'block'){
                    floatingMenu.style.display = 'none';
                } else {
                    floatingMenu.style.display = 'block';
                    floatingMenu.style.top = `${event.y - 50}px`; // Rough approximation
                }
    
                // Adding listeners to each floating menu item to close the floating menu when selected
                let floatingListElements = floatingMenu.children[0].children;
                for (let j = 0; j < floatingListElements.length; j++) {
                    floatingListElements[j].children[0].addEventListener('click', function(){
                        floatingMenu.style.display = 'none';
                    });
                }
            } else {
                floatingMenu.style.display = 'none';
            }
        }

        // Iterating the clicked header's siblings
        for(let i=0; i<menuHeaders.length; i++){
            let sibling = menuHeaders[i].children[0];
            // Will remove the highlighting of main menu provided the selection isn't in a submenu
            if(sibling !== self && !submenu){
                sibling.className = sibling.className.replace(' activeStateButton', '');
            }

            // Closing other open submenus
            if(menuHeaders[i] !== parent && !submenu){
                if(menuHeaders[i].className.includes('mainMenuHeaderExpanded')){
                    menuHeaders[i].className = menuHeaders[i].className.replace('mainMenuHeaderExpanded', '');
                }
            }
        }
    }

    /**
     Generates HTML based on the props.js file using NavFactory to
    * scaffold out the components
    * 
    * Grabs references and adds event listeners
    */
    generateContent(){
        // Self defined for referencing clickHandler
        let self = this;
        this.createNavBar();

        // Referencing the new navbar
        let navigationBar         = document.getElementById('menuId');
        let toggleButton          = document.getElementById('menuToggle');
        let centerPane            = document.getElementById('geotabDriveScratchie');
        let chevronIcon           = toggleButton.children.item(0);
        let menuHeaders           = document.getElementsByClassName('mainMenuHeader');
        let floatingMenu          = document.getElementById('hiddenMenu');
        let navigationBarExtended = true;

        // Handling Navbar pop in/out
        toggleButton.addEventListener('click', ()=>{
            if(!navigationBarExtended){
                navigationBar.className = navigationBar.className.replace('menuCollapsed', '');
                centerPane.style.left = '250px';
                chevronIcon.style.transform = 'rotate(0deg)';
            } else {
                navigationBar.className += ' menuCollapsed';
                centerPane.style.left = '50px';
                chevronIcon.style.transform = 'rotate(180deg)';
            }
             // Closing the floating menu
             floatingMenu.style.display = 'none';

             // Closing any open menu headers
             for(let i=0; i<menuHeaders.length; i++){
                 menuHeaders[i].className = menuHeaders[i].className.replace(' mainMenuHeaderExpanded', '');
             }
 
             // Inverting extended status
            navigationBarExtended = !navigationBarExtended
        });
        
        // Handling Button click (Highlighting)
        for(let i=0; i<menuHeaders.length; i++){
            let submenu = menuHeaders[i].children[1];
            if(submenu){
                let menuItems = submenu.children[0].children;
                // Adding in the selection and menu handlers for submenu items
                if(navigationBarExtended){
                    for (let j = 0; j < menuItems.length; j++) {
                        menuItems[j].children[0].addEventListener('click', function(event){
                            self.clickHandler(event, this, menuHeaders, floatingMenu, navigationBarExtended, true);
                        });
                    }
                } 
            } 
            // All menu headers require the functionality
            menuHeaders[i].children[0].addEventListener('click', function(event){
                self.clickHandler(event, this, menuHeaders, floatingMenu, navigationBarExtended);
            });
        }   
    }

    createNavBar(){
        // Generating Navbar
        let navHTML = ``;
        let navBase = document.getElementById('navBase');
        let headerCount = 0;

        // Reading the JSON props file and building out the navbar
        this.props.forEach(prop => {
            prop.id = headerCount;
            // Main header
            navHTML += this.navFact.openMainHeader(prop);
            if(prop.hasSubmenu){
                // Sub Menu
                navHTML += this.navFact.openSubMenu(prop);
                prop.submenuItems.forEach( item => {
                    // Sub header
                    navHTML += this.navFact.subHeader(item);
                })
                navHTML += this.navFact.closeSubMenu();
            }
            navHTML += this.navFact.closeMainHeader();
            headerCount++;
        });
        navBase.innerHTML = navHTML;
    }

    updateMenuItem(){
        this.createNavBar();
    }

    /**
     * Toggles the development addin
     * allows user to see any processes that take place when the addin is blurred/focused
     */
    enableDisplayToggle(){
        let displayToggle = document.getElementById('toggleBtn');
        displayToggle.addEventListener('click', () => {
            if(this.focus){
                displayToggle.innerHTML = 'Focus add-in';
                global.geotab.addin.geotabDriveScratchie.blur();
            } else {
                displayToggle.innerHTML = 'Blur add-in';
                global.geotab.addin.geotabDriveScratchie.focus(global.api, global.state);
            }
            this.focus = !this.focus;
        });
    }
    
    /**
     * Hash listener -> Due to the call stack order, it's necessary to repeatedly check for this
     * during page operation. This is what we base the blur() effect on. Without this, when we 
     * try to update the hash, we get the previous one, causing the update to be one behind the 
     * active hash.
     * 
     * onHashChange does not appear to be supported as an event in this browser
     */
    listenToHash(){
        this.storedHash = window.location.hash;
        setInterval(()=>{
            if(window.location.hash !== this.storedHash){
                this.storedHash = window.location.hash;
                if(this.storedHash !== '#' + 'geotabDriveScratchie'){
                    geotab.addin.geotabDriveScratchie.blur();
                } else {
                    geotab.addin.geotabDriveScratchie.focus(global.api, global.state);
                }
            }
        }, 100);
    }

} 

module.exports = NavHandler;```


## File: ./src/.dev/navbar/props.js

```js
const config = require('../../config.json');
/**
 * Props item - Houses all the navbar items and submenu items
 */
const props = [
    
    
    
    
    
    
     
];

module.exports = props;```


## File: ./src/.dev/navbar/NavBuilder.js

```js

let NavFactory = require('./NavFactory');
let NavHandler = require('./NavHandler');
let props = require('./props');
let language = localStorage.language ? localStorage.language : 'en';

let factory = new NavFactory(language);
let handler = new NavHandler(factory, props);


// handler.enableDisplayToggle();
```


## File: ./src/.dev/ToggleHandler.js

```js
class ToggleHandler{
    /**
     * Toggles the development addin
     * allows user to see any processes that take place when the addin is blurred/focused
     */
    constructor(){
        this.focus = true;
        let displayToggle = document.getElementById('toggleBtn');
        let centerPane = document.querySelector('#geotabDriveScratchie')
        displayToggle.addEventListener('click', () => {
            if(this.focus){
                displayToggle.innerHTML = 'Focus add-in';
                centerPane.className = " centerPane"
                global.geotab.addin.geotabDriveScratchie.blur();
            } else {
                displayToggle.innerHTML = 'Blur add-in';
                centerPane.className += " hidden"
                global.geotab.addin.geotabDriveScratchie.focus(global.api, global.state);
            }
            this.focus = !this.focus;
        });
    }

}

new ToggleHandler();```


## File: ./src/.dev/index.js

```js
/**
 * Entry point for serving the app on localhost
 * Allows several UI features to be displayed to improve
 * development without adding them in to the final
 * build sent to production
 * 
 * ******************** NOTE ********************
 * 
 *  Any features built into this file will not be included in
 * the addin build. Any changes you want included should be in
 * app/index.js instead.
 * 
 * **********************************************
 */


// Global object is used to simulate the api, state, and geotab objects
global.api
global.state = require('./state');
global.geotab = {
    addin: {}, 
    customButtons: {}, 
    isDriveAddin: true
}
// Importing the app rules -> Where addin will be described

require('../app/scripts/main');

// Importing dev-specific packages
import './rison';
import './login/loginTemplate.js';
import GeotabLogin from './login/loginLogic';
import GeotabApi from './api';

// Building navbar
// Exposing handler to let the translate function have access to it
import './navbar/NavBuilder';

// Global Translate function
global.state.translate = function(target, language) {
    
    // First translation from initialize doesn't pass a language in. Will cause problems is language is undefined
    if (typeof language !== 'undefined'){
        localStorage.language = language;
        location.reload();
    }

    // Primary behaviour passes HTMLElement, but function needs to support string translation as well
    if (typeof target === 'string'){
        // Do translation
        let translation = global.translator.translateSentence(target);
        // return translated string
        return translation;
    }
}

/* Logic */
const loginLogic = new GeotabLogin(global.geotab.isDriveAddin, GeotabApi);



// Handling the blur toggle
require('./ToggleHandler');




// Setup complete
/* Addin Logic */
require('../app/index');
```


## File: ./src/.dev/styles/styleGuideMyGeotab.html

```html
<!DOCTYPE html>
<html>
	<head>
	<title>Public Style</title>
	<link rel="stylesheet" href="https://my.geotab.com/geotab/checkmate/main.css?skin=my_geotab">
	<link rel="stylesheet" href="styles.css">
</head>
<body>
	<div id="parent" class="container">
		<div class="item">
			<h2>Main colors</h2>
			<div class="example">
				<div class="boxWrapper">
					<div>
						Background colors
					</div>
					<div class="box geotabPrimaryFill"></div>
					<div class="box geotabSecondaryFill"></div>
				</div>
				<div class="boxWrapper">
					<div>
						Text colors
					</div>
					<div class="box geotabPrimaryText">A</div>
					<div class="box geotabSecondaryText">B</div>
					<div class="box geotabUsualText">C</div>
				</div>
				<div class="boxWrapper">
					<div>
						Border colors
					</div>
					<div class="box geotabPrimaryBorder"></div>
					<div class="box geotabSecondaryBorder"></div>
				</div>

				<div class="boxWrapper">
					<div>
						Standard UI element
					</div>
					<div class="box geotabUIElement">A</div>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;div class="<mark>geotabPrimaryFill</mark>"&gt;&lt;/div&gt;</code>
					<code>&lt;div class="<mark>geotabSecondaryFill</mark>"&gt;&lt;/div&gt;</code>
					<br>
					<code>&lt;div class="<mark>geotabPrimaryText</mark>"&gt;A&lt;/div&gt;</code>
					<code>&lt;div class="<mark>geotabSecondaryText</mark>"&gt;B&lt;/div&gt;</code>
					<code>&lt;div class="<mark>geotabUsualText</mark>"&gt;C&lt;/div&gt;</code>
					<br>
					<code>&lt;div class="<mark>geotabPrimaryBorder</mark>"&gt;&lt;/div&gt;</code>
					<code>&lt;div class="<mark>geotabSecondaryBorder</mark>"&gt;&lt;/div&gt;</code>
					<br>
					<code>&lt;div class="<mark>geotabUIElement</mark>"&gt;A&lt;/div&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Page Name</h2>
			<div class="example">
				<div class="geotabPageHeader">
					<h1 class="geotabPageName">Page Name <span class="subdued">with sub title</span></h1>
					<div class="pageNameSecondary">
						<h3 class="geotabSecondaryTitle">and additional information</h3>
					</div>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;div class="<mark>geotabPageHeader</mark>"&gt;</code>
					<code>	&lt;h1 class="<mark>geotabPageName</mark>"&gt;Page Name &lt;span class="<mark>subdued</mark>"&gt;with sub title&lt;/span&gt;&lt;/h1&gt;</code>
					<code>	&lt;div class="<mark>pageNameSecondary</mark>"&gt;</code>
					<code>		&lt;h3 class="<mark>geotabSecondaryTitle</mark>"&gt;and additional information&lt;/h3&gt;</code>
					<code>	&lt;/div&gt;</code>
					<code>&lt;/div&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Buttons</h2>
			<div class="example">
				<div class="buttons">
					<button class="geotabButton">Button</button>

					<button class="geotabButton" disabled>Disabled button</button>

					<button class="geotabButton negativeButton">Refuse</button>

					<button class="geotabButton positiveButton">Approve</button>

					<a href="https://www.geotab.com/connect.html" target="_blank" class="geotabButton">Link to Connect</a>

					<input type="checkbox" id="someCheckbox" class="geotabSwitchButton">
					<label class="geotabButton" for="someCheckbox">Checkbox</label>

					<input type="radio" name="someRadio" id="someRadio1" class="geotabSwitchButton" checked>
					<label class="geotabButton" for="someRadio1">On</label>
					<input type="radio" name="someRadio" id="someRadio2" class="geotabSwitchButton">
					<label class="geotabButton" for="someRadio2">Off</label>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;button class="<mark>geotabButton</mark>"&gt;Button&lt;/button&gt;</code>
					<br>
					<code>&lt;button class="<mark>geotabButton</mark> disabled"&gt;Disabled button&lt;/button&gt;</code>
					<br>
					<code>&lt;button class="<mark>geotabButton negativeButton</mark>"&gt;Button&lt;/button&gt;</code>
					<br>
					<code>&lt;button class="<mark>geotabButton positiveButton</mark>"&gt;Button&lt;/button&gt;</code>
					<br>
					<code>&lt;a href="#" class="<mark>geotabButton</mark>"&gt;Link&lt;/a&gt;</code>
					<br>
					<code>&lt;input type="checkbox" id="someCheckbox" class="<mark>geotabSwitchButton</mark>"&gt;</code>
					<code>&lt;label class="<mark>geotabButton</mark>" for="someCheckbox"&gt;Checkbox&lt;/label&gt;</code>
					<br>
					<code>&lt;input type="radio" name="someRadio" id="someRadio1" class="<mark>geotabSwitchButton</mark>" checked&gt;</code>
					<code>&lt;label class="<mark>geotabButton</mark>" for="someRadio1"&gt;On&lt;/label&gt;</code>
					<code>&lt;input type="radio" name="someRadio" id="someRadio2" class="<mark>geotabSwitchButton</mark>"&gt;</code>
					<code>&lt;label class="<mark>geotabButton</mark>" for="someRadio2"&gt;Off&lt;/label&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Horizontal button sets</h2>
			<div class="example">
				<div class="horizontalButtonSet">
					<button class="geotabButton">Button 1</button>
					<button class="geotabButton">Button 2</button>
					<button class="geotabButton">Button 3</button>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;div class="<mark>horizontalButtonSet</mark>"&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 1&lt;/button&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 2&lt;/button&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 3&lt;/button&gt;</code>
					<code>&lt;/div&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Vertical button sets</h2>
			<div class="example">
				<div class="verticalButtonSet w">
					<button class="geotabButton">Button 1</button>
					<button class="geotabButton">Button 2</button>
					<button class="geotabButton">Button 3</button>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;div class="<mark>verticalButtonSet</mark>"&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 1&lt;/button&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 2&lt;/button&gt;</code>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button 3&lt;/button&gt;</code>
					<code>&lt;/div&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Form</h2>
			<div class="example">
				<fieldset class="geotabFieldset">
					<div class="geotabField">
						<label>Name:</label>
						<input placeholder="Field with label" type="text" class="geotabFormEditField" maxlength="255">
					</div>
					<div class="geotabField">
						<label>Disabled field:</label>
						<input placeholder="Disabled field" type="text" class="geotabFormEditField" maxlength="255" disabled>
					</div>
					<div class="geotabField">
						<input placeholder="Field without label" class="fieldWithoutLabel geotabFormEditField" maxlength="255">
					</div>
					<div class="geotabField">
						<label>Comment:</label>
						<textarea placeholder="Textarea with label"  cols="30" class="geotabFormEditField" rows="5"></textarea>
					</div>
					<div class="geotabField">
						<div class="fieldWithoutLabel singleField">
							<q>Sir, in my heart there was a kind of fighting
							That would not let me sleep. Methought I lay
							Worse than the mutines in the bilboes. Rashlyâ€”
							And prais'd be rashness for itâ€”let us know
							Our indiscretion sometimes serves us well...</q>

							<cite class="quote">Hamlet, Act 5, Scene 2, 4â€“8</cite>
						</div>
					</div>
					<div class="geotabField">
						<label>Switcher:</label>

						<span class="horizontalButtonSet">
							<input type="radio" name="switcher" class="geotabSwitchButton" id="switcher1" checked>
							<label class="geotabButton" for="switcher1">Yes</label>
							<input type="radio" name="switcher" id="switcher2" class="geotabSwitchButton">
							<label class="geotabButton" for="switcher2">No</label>
						</span>
					</div>
					<div class="geotabField">
						<label>Actions</label>
						<div class="verticalButtonSet">
							<input type="checkbox" class="geotabSwitchButton" id="Actions1" />
							<label class="geotabButton" for="Actions1">Action 1</label>
							<input type="checkbox" id="Actions2" class="geotabSwitchButton">
							<label class="geotabButton" for="Actions2">Action 2</label>
							<input type="checkbox" id="Actions3" class="geotabSwitchButton">
							<label class="geotabButton" for="Actions3">Action 3</label>
						</div>
					</div>
				</fieldset>
			</div>
			<div class="code">
				<pre>
					<code>&lt;fieldset class="<mark>geotabFieldset</mark>"&gt;</code>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;label&gt;Name:&lt;/label&gt;</code>
					<code>		&lt;input type="text" class="<mark>geotabFormEditField</mark>" maxlength="255"&gt;</code>
					<code>	&lt;/div&gt;</code>
					<br>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;input type="text" class="<mark>fieldWithoutLabel geotabFormEditField</mark>" maxlength="255"&gt;</code>
					<code>	&lt;/div&gt;</code>
					<br>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;label&gt;Comment:&lt;/label&gt;</code>
					<code>		&lt;textarea cols="30" class="<mark>geotabFormEditField</mark>" rows="5"&gt;&lt;/textarea&gt;</code>
					<code>	&lt;/div&gt;</code>
					<br>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;div class="<mark>fieldWithoutLabel singleField</mark>"&gt;&lt;q&gt;Sir, in ... us well&lt;/q&gt;&lt;/div&gt;</code>
					<code>	&lt;/div&gt;</code>
					<br>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;label&gt;Switcher:&lt;/label&gt;</code>
					<code>		&lt;span class="<mark>horizontalButtonSet</mark>"&gt;</code>
					<code>			&lt;input type="radio" name="switcher" class="geotabSwitchButton" id="switcher1" checked&gt;</code>
					<code>			&lt;label class="geotabButton" for="switcher1"&gt;Yes&lt;/label&gt;</code>
					<code>			&lt;input type="radio" name="switcher" id="switcher2" class="geotabSwitchButton"&gt;</code>
					<code>			&lt;label class="geotabButton" for="switcher2"&gt;No&lt;/label&gt;</code>
					<code>		&lt;/span&gt;</code>
					<code>	&lt;/div&gt;</code>
					<br>
					<code>	&lt;div class="<mark>geotabField</mark>"&gt;</code>
					<code>		&lt;label&gt;Actions&lt;/label&gt;</code>
					<code>		&lt;div class="<mark>verticalButtonSet</mark>"&gt;</code>
					<code>			&lt;input type="checkbox" class="geotabSwitchButton" id="Actions1" /&gt;</code>
					<code>			&lt;label class="geotabButton" for="Actions1"&gt;Action 1&lt;/label&gt;</code>
					<code>			&lt;input type="checkbox" id="Actions2" class="geotabSwitchButton"&gt;</code>
					<code>			&lt;label class="geotabButton" for="Actions2"&gt;Action 2&lt;/label&gt;</code>
					<code>			&lt;input type="checkbox" id="Actions3" class="geotabSwitchButton"&gt;</code>
					<code>			&lt;label class="geotabButton" for="Actions3"&gt;Action 3&lt;/label&gt;</code>
					<code>		&lt;/div&gt;</code>
					<code>	&lt;/div&gt;</code>
					<code>&lt;/fieldset&gt;</code>
				</pre>
			</div>
		</div>

		<div class="item">
			<h2>Toolbar</h2>
			<div class="example">
				<div class="geotabToolbar">
					<input type="text" placeholder="Search something" class="geotabFormEditField w" />
					<button class="geotabButton">Button</button>
					<a href="https://www.geotab.com/connect.html" target="_blank" class="geotabButton">Link to Connect</a>

					<div class="horizontalButtonSet">
						<input type="radio" name="someRadio2" id="toolbarRadio1" class="geotabSwitchButton" checked>
						<label class="geotabButton" for="toolbarRadio1">First option</label>
						<input type="radio" name="someRadio2" id="toolbarRadio2" class="geotabSwitchButton">
						<label class="geotabButton" for="toolbarRadio2">Second option</label>
					</div>
				</div>
			</div>
			<div class="code">
				<pre>
					<code>&lt;div class="<mark>geotabToolbar</mark>"&gt;</code>
					<code>	&lt;input type="text" placeholder="Search something" class="<mark>geotabFormEditField</mark>" /&gt;</code>
					<br>
					<code>	&lt;button class="<mark>geotabButton</mark>"&gt;Button&lt;/button&gt;</code>
					<br>
					<code>	&lt;a href="https://www.geotab.com/connect.html" target="_blank" class="<mark>geotabButton</mark>"&gt;Link to Connect&lt;/a&gt;</code>
					<br>
					<code>	&lt;div class="<mark>horizontalButtonSet</mark>"&gt;</code>
					<code>		&lt;input type="radio" name="someRadio2" id="toolbarRadio1" class="<mark>geotabSwitchButton</mark>" checked&gt;    </code>
					<code>		&lt;label class="<mark>geotabButton</mark>" for="toolbarRadio1"&gt;First option&lt;/label&gt;</code>
					<code>		&lt;input type="radio" name="someRadio2" id="toolbarRadio2" class="<mark>geotabSwitchButton</mark>"&gt;    </code>
					<code>		&lt;label class="<mark>geotabButton</mark>" for="toolbarRadio2"&gt;Second option&lt;/label&gt;</code>
					<code>	&lt;/div&gt;</code>
					<code>&lt;/div&gt;</code>
				</pre>
			</div>
		</div>
	</div>
</body>
</html>
```


## File: ./src/.dev/styles/styleGuide.css

```css
.container {
	width: 90%;
    margin: auto;
}

mark {
	background: #FAFAA2;
	padding: 3px 8px;
    border-radius: 8px;
    color: #000;
}

code {
	display: block;
    padding: 0;
    background: 0 0;
    white-space: pre;
    line-height: 2;
}

.box {
    border-width: 1px;
    border-style: solid;
    border-radius: 3px;
    width: 40px;
    height: 40px;
    float: left;
    margin: 5px;
    font-size: 2em;
    text-align: center;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.boxWrapper {
    margin-left: 40px;
    float: left;
    overflow: hidden;
}

pre {
	margin: 0;
    padding: 1px 0 0;
    white-space: normal;
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
}

.quote {
    float: right;
}

.example, .code {
	overflow: hidden;
    position: relative;
    margin: 0;
    padding: 25px 19px 10px;
    background-color: #fefefe;
    border: 1px solid #ddd;
    border-radius: 2px;
}

.w {
    width: 200px;
}

.buttons > * {
	float: left;
	margin-left: 10px;
	line-height: normal;
}

.code {
	border-top: 0;
}

.example:after,
.code:after {
    position: absolute;
    top: -1px;
    left: -1px;
    padding: 3px 7px;
    font-size: 12px;
    font-weight: bold;
    background-color: #f5f5f5;
    border: 1px solid #ddd;
    color: #9da0a4;
    border-radius: 4px 0 4px 0;
}

.example:after {
	content: "Example";
}

.code:after {
	content: "Code";
}
```


## File: ./src/.dev/state.js

```js
const state = {
    // Not available in myGeotab - addin use only.
    _activeGroups: [],
    _advancedGroupsFilter: {},
    getState: function () {
        var hash = location.hash,
            hashLength = hash.length;
        return !hashLength ? {} : rison.decode(location.hash.substring(1, location.hash.length));
    },
    setState: function (s) {
        location.hash = Object.keys(s).length ? '#' + rison.encode(s) : '';
    },
    gotoPage: function (page, args) {
        var getUrl = function (targetClass, targetState) {
            var lcClassHtml = location.pathname.replace(/\./g, '/').toLowerCase(),
                url = document.URL,
                pos = url.toLowerCase().indexOf(lcClassHtml),
                encodedState = targetState ? '#' + rison.encode(targetState) : '';

            if (targetClass.indexOf('.') === -1) {
                targetClass = 'geotab.checkmate.ui.' + targetClass;
            }

            // This is the default scheme for standalone pages.
            targetClass = targetClass.replace(/\./g, '/');
            if (targetClass.toLowerCase() === lcClassHtml) {
                //staying on the same page - just replace hash component
                return url.replace(/\.html.*$/i, '.html' + encodedState);
            }
            return url.slice(0, pos) + targetClass + '.html' + encodedState;
        };

        window.location = getUrl(page, args);
    },
    hasAccessToPage: function (page) {
        return !!page;
    },
    getGroupFilter: function () {
        return this._activeGroups;
    },
    getAdvancedGroupsFilter: function () {
        return this._advancedGroupsFilter;
    }
};

module.exports = state;```


## File: ./src/.dev/api.js

```js
/**
 *  @version 2014-07-21
 *  @description The Geotab JS API library.
 *  Used to login and make any API calls to a Geotab server.
 *
 *  Automatically prompts the user to login if the password is changed or if the
 *  database is moved to another server.
 *
 *  If credentials are required (for example, the first time you've visited the page, the
 *  database has moved or the user's password has changed, etc.), the 'getCredentialsCallback' is executed
 *  with a callback function that can be used on your end to pass credentials into the system. When
 *  you call this function, any pending calls will also be completed automatically.

 *  @example
 *  var api = GeotabApi(function(authenticateCallback) {
 *      // We need credentials; we either never had them, or lost them (the server was moved, password
 *      // changed, etc.)
 *
 *      someLoginDialog.style.display = 'block'; // Show a login dialog
 *      someLoginButton.addEventListener('click', function () {
 *          // Call to authenticate
 *          authenticateCallback(serverField.value, databaseField.value, emailField.value, passwordField.value, function(errorString) {
 *              alert(errorString);
 *          });
 *      });
 *  })
 *  @function
 *  @param {Function} getCredentialsCallback This function is called when this class can't login or is
 *                                      fetching credentials for the first time
 *  @param {Object} [newOptions] Can be used to override default values in the 'options' variable
 *  @param {Object} [customCredentialStore] Override the default localStorage-based credential storage
 with a custom storage implementation
 */
var GeotabApi = function (getCredentialsCallback, newOptions, customCredentialStore) {
    'use strict';
    var JSONP_REQUESTS_PROPERTY_STR = 'geotabJSONP',
        credentials,
        server,
        pendingCalls = [],
        options = {
            // Use localStorage to store credentials automatically
            rememberMe: true,
            // Show debugging information (in Chrome dev tools, Firebug, etc.)
            debug: false,
            // Use JSONP for all calls (for using the API without running a server)
            jsonp: false,
            // How long to wait for a response from the server (in seconds); 0 (or null) means no timeout.
            timeout: 0
        },
        credentialsStore,
        /**
         *  Logs some debug information to the browser console, if options.debug is true
         *  @private
         */
        debugLog = function () {
            if (options.debug) {
                var logs = [new Date()];
                logs.push.apply(logs, arguments);
                console.log.apply(console, logs);
            }
        },
        /**
         *  Normalizes and handles errors
         *  @private
         *  @param {Object} [error] The error object
         *  @callback {failureCallback} [errorCallback] The function to call once the error has been normalize.
         *                                                  It passes back a string for a known error, and the raw error
         *                                                  object if some custom handling is required.
         */
        handleError = function (error, errorCallback) {
            var errorString;
            if (error.errors && error.errors.length > 0) {
                error = error.errors[0];
            }
            if (error && error.name && error.message) {
                errorString = error.name + ': ' + error.message;
            } else if (error.target || (error instanceof XMLHttpRequest && error.status === 0)) {
                errorString = 'Network Error: Couldn\'t connect to the server. Please check your network connection and try again.';
            }
            if (options.debug) {
                console.error(errorString, error);
            }
            if (errorCallback) {
                errorCallback(errorString || 'Error', error);
            }
        },
        /**
         * Gets the method call URL
         * @private
         * @param {String} [method] The method to call on the server
         * @return {String} The method call URL string
         */
        getCallUrl = function (method) {
            var thisServer = server.replace(/\S*:\/\//, '').replace(/\/$/, '');
            return location.protocol + '//' + thisServer + '/apiv1' + (method ? '/' + method : '');
        },
        /**
         *  Cleans up the call with the given unique ID
         *  @private
         *  @param {String} uid The unique ID of the response callback
         */
        cleanupCall = function (uid) {
            // Remove this function once we're done with it
            var script = document.getElementById(uid);
            if (script) {
                script.parentNode.removeChild(script);
                // Manually garbage-collect the script
                for (var prop in script) {
                    if (script.hasOwnProperty(prop)) {
                        delete script[prop];
                    }
                }
            }
            delete window[JSONP_REQUESTS_PROPERTY_STR][uid];
        },
        /**
         *  Construct a JSONP request for a Geotab API call
         *  @private
         *  @param {String} method The name of the API method
         *  @param {Object} params The method parameters
         *  @param {successCallback} callbackSuccess The function that is called if the method call was successful
         *  @param {failureCallback} [callbackError] The function that is called if the method call failed
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        callJSONP = function (method, params, callbackSuccess, callbackError) {
            var uid = 'json' + (Math.random() * 100).toString().replace(/\./g, ''),
                buildParamString = function () {
                    params = params || {};
                    var query = [];
                    for (var key in params) {
                        if (params.hasOwnProperty(key)) {
                            query.push.apply(query, ['&', encodeURIComponent(key), '=', encodeURIComponent(JSON.stringify(params[key]))]);
                        }
                    }
                    return query.join('');
                },
                timeoutTimer;

            window[JSONP_REQUESTS_PROPERTY_STR][uid] = function JSONPResponse(data) {
                // Clear timeout timer first
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                    timeoutTimer = null;
                }

                // Try to handle the response from the server
                try {
                    if (data && data.error) {
                        debugLog(method, 'ERROR', data.error);
                        handleError(data.error, callbackError);
                    } else {
                        var result = data.result;
                        debugLog(method, 'SUCCESS', {
                            result: result
                        });
                        if (callbackSuccess) {
                            callbackSuccess(result);
                        }
                    }
                } finally {
                    cleanupCall(uid);
                }
            };
            document.getElementsByTagName('body')[0].appendChild((function () {
                var s = document.createElement('script');
                s.type = 'text/javascript';
                s.id = uid;
                s.async = 'async';
                s.src = getCallUrl(method) + '?JSONP=' + JSONP_REQUESTS_PROPERTY_STR + '.' + uid + buildParamString();
                s.onerror = function JSONPError(error) {
                    try {
                        debugLog('CallJSONP', method, 'ERROR', error);
                        handleError(error, callbackError);
                    } finally {
                        cleanupCall(uid);
                    }
                };
                return s;
            })());

            if (timeoutTimer) {
                clearTimeout(timeoutTimer);
            }
            if (options.timeout && method !== 'Authenticate') {
                timeoutTimer = setTimeout(function () {
                    if (window[JSONP_REQUESTS_PROPERTY_STR].hasOwnProperty(uid)) {
                        window[JSONP_REQUESTS_PROPERTY_STR][uid]({
                            error: {
                                name: 'JSONPTimeout',
                                message: 'Could not complete the JSONP request in a timely manner (' + options.timeout + 's)',
                                target: document.getElementById(uid)
                            }
                        });
                        window[JSONP_REQUESTS_PROPERTY_STR][uid] = function () {
                            cleanupCall(uid);
                        };
                    }
                }, options.timeout * 1000);
            }
            return {
                abort: function () {
                    cleanupCall(uid);
                    if (errorCallback) {
                        errorCallback('Cancelled', {});
                    }
                }
            }
        },
        /**
         *  Construct an XMLHttpRequest POST request for a Geotab API call
         *  @private
         *  @param {String} method The name of the API method
         *  @param {Object} params The method parameters
         *  @param {successCallback} callbackSuccess The function that is called if the method call was successful
         *  @param {failureCallback} [callbackError] The function that is called if the method call failed
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        callXHR = function (method, params, callbackSuccess, callbackError) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', getCallUrl(), true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.addEventListener('abort', function (e) {
                if (callbackError) {
                    callbackError('Cancelled', e);
                }
            });
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var data,
                            error,
                            result;
                        try {
                            data = JSON.parse(xhr.responseText);
                            if (data && data.error) {
                                error = data.error;
                                debugLog(method, 'ERROR', error);
                                handleError(error, callbackError);
                            } else {
                                result = data.result;
                                debugLog(method, 'SUCCESS', {
                                    result: result
                                });
                                callbackSuccess(result);
                            }
                        } catch (e) {
                            handleError(e, callbackError);
                        }
                    } else {
                        debugLog(method, 'ERROR', xhr);
                        handleError(xhr, callbackError);
                    }
                }
            };
            var rpcString;
            try {
                rpcString = JSON.stringify({
                    method: method || '',
                    params: params
                });
            } catch (e) {
                handleError(e, callbackError);
                return;
            }
            if (options.timeout) {
                xhr.timeout = options.timeout * 1000;
            }
            xhr.send('JSON-RPC=' + encodeURIComponent(rpcString));
            return {
                abort: function () {
                    xhr.abort();
                }
            }
        },
        /**
         *  Construct a request for a Geotab API call
         *  @private
         *  @param {String} method The name of the API method
         *  @param {Object} params The method parameters
         *  @param {successCallback} callbackSuccess The function that is called if the method call was successful
         *  @param {failureCallback} [callbackError] The function that is called if the method call failed
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        callBase = function (method, params, callbackSuccess, callbackError) {
            if (options.jsonp) {
                return callJSONP(method, params, callbackSuccess, callbackError);
            }
            return callXHR(method, params, callbackSuccess, callbackError);
        },
        /**
         *  Authenticates a Geotab user
         *  @private
         *  @param {String} newServer The federation server name string
         *  @param {String} database The database name
         *  @param {String} username The username/email to authenticate with
         *  @param {String} password The password to authenticate with
         *  @param {successCallback} callbackSuccess The function that is called on the successful authentication
         *  @param {failureCallback} [callbackError] The function that is called when there is an
         *                                            authentication failure with the error string and the
         *                                            error objects as parameters
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        authenticateWithServer = function (newServer, database, username, password, callbackSuccess, callbackError) {
            server = newServer;
            // Authenticate the user
            return callBase('Authenticate', {
                database: database,
                userName: username,
                password: password
            }, function (data) {
                if (data.path && data.path !== 'ThisServer') {
                    server = 'https://' + data.path + '/';
                }
                credentials = data.credentials;
                if (options.rememberMe) {
                    credentialsStore.set(credentials, server);
                }
                if (callbackSuccess) {
                    callbackSuccess();
                }
            }, callbackError);
        },
        /**
         *  Populates the authenticate callback with a function
         *  @private
         *  @param {successCallback} [callbackSuccess] Called when we have successfully authenticated
         */
        populateAuthenticationCallback = function (callbackSuccess) {
            getCredentialsCallback(function (newServer, database, username, password, error) {
                return authenticateWithServer(newServer, database, username, password, function () {
                    if (callbackSuccess) {
                        callbackSuccess();
                    }
                    // Try again
                    pendingCalls.forEach(function (p) {
                        call.apply(this, p);
                    });
                    pendingCalls = [];
                }, error);
            });
        },
        /**
         *  Calls a Geotab method. Handles cases where the credentials have expired or are invalid.
         *  @public
         *  @param {String} method The name of the API method
         *  @param {Object} params The method parameters object.
         *  @param {successCallback} callbackSuccess The function that is called if the method call was successful
         *  @param {failureCallback} [callbackError] The function that is called if the method call failed
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        call = function (method, params, callbackSuccess, callbackError) {
            var
                needsLoginAndCall = function () {
                    pendingCalls.push([method, params, callbackSuccess, callbackError]);
                    var storedCredentials = credentialsStore.get();
                    if (storedCredentials && options.rememberMe) {
                        credentials = storedCredentials.credentials;
                        server = storedCredentials.server;
                        // Try again
                        pendingCalls.forEach(function (p) {
                            call.apply(this, p);
                        });
                        pendingCalls = [];
                    } else {
                        populateAuthenticationCallback();
                    }
                };
            if (!credentials) {
                needsLoginAndCall();
                return {
                    abort: function () { }
                };
            }
            params.credentials = credentials;
            return callBase(method, params, callbackSuccess, function (errorString, errorObject) {
                var errors = errorObject.errors;
                if (errors && errors[0] && errors[0].name === 'InvalidUserException' && method !== 'Authenticate') {
                    // We do have a credentials token, but it's no longer valid
                    // Let's clear it
                    credentialsStore.clear();
                    needsLoginAndCall();
                } else {
                    if (callbackError) {
                        callbackError(errorString, errorObject);
                    }
                }
            });
        },
        /**
         *  Calls multiple Geotab methods at the same time. Returns an array of results corresponding to the order the calls are passed in
         *  @public
         *  @param {Array} calls The calls array. For each entity in this array, we expect a 1 or 2 item array: the first
         *                                               item is the method name, and (optionally) the second is an object of the method parameters
         *                                               eg. [
         *                                                      ['GetVersion'],
         *                                                      ['Get', { typeName: 'Device', search: { serialNumber: 'GTA1234556678' } }],
         *                                                      ['Add', { typeName: 'Device', entity: { name: 'New Device', serialNumber: 'GTA0000000000' }]
         *                                                   ]
         *  @param {successCallback} callbackSuccess The function that is called if the method calls were all successful
         *  @param {failureCallback} [callbackError] The function that is called if any method call failed
         *  @return {Object} An object with operations for the call. Supported operation(s): abort()
         */
        multiCall = function (calls, callbackSuccess, callbackError) {
            var formattedCalls = calls.map(function (call) {
                var params = call[1];
                return {
                    method: call[0],
                    params: params
                };
            });
            return call('ExecuteMultiCall', {
                calls: formattedCalls
            }, callbackSuccess, callbackError);
        },
        /**
         *  Retrieves a session. Useful for single sign-on or other cases where you require the credentials
         *  @param {successCallback} callbackSuccess The function that is called if the retrieval of sessionId was successful
         *  @param {Boolean} [newSession] If true, always retrieve a new session from the server. Otherwise, return the current session (if active) or
         *                              retrieve a new one from the server if there are no active sessions
         */
        getSession = function (callbackSuccess, newSession) {
            var storedCredentials = credentialsStore.get();
            if (!newSession && storedCredentials && options.rememberMe) {
                if (callbackSuccess) {
                    callbackSuccess(storedCredentials.credentials, storedCredentials.server);
                }
                return;
            }
            populateAuthenticationCallback(function () {
                if (callbackSuccess) {
                    // At this point, 'credentials' and 'server' have been set within populateAuthenticationCallback()
                    callbackSuccess(credentials, server);
                }
            });
        },
        /**
         *  Clears credentials and the credential store.
         *  @public
         */
        forget = function () {
            credentials = null;
            credentialsStore.clear();
            populateAuthenticationCallback();
        };

    // Overrides default options with passed in ones, if there are any
    if (newOptions) {
        for (var prop in newOptions) {
            if (newOptions.hasOwnProperty(prop)) {
                options[prop] = newOptions[prop];
            }
        }
    }

    // Creates a property for managing open requests
    window[JSONP_REQUESTS_PROPERTY_STR] = {};

    /**
     *  The default credentials store. Uses localStorage to save and retrieve
     *  credentials to save a user's session.
     */
    var defaultCredentialsStore = {
        CREDENTIALS_KEY: 'geotabAPI_credentials',
        SERVER_KEY: 'geotabAPI_server',
        /**
         *  Gets the credentials from localStorage
         *  @returns {*} An object with two properties: 'server', a server name
         *                      string, and 'credentials', a credentials object
         */
        get: function () {
            var storedCredentials = localStorage.getItem(this.CREDENTIALS_KEY),
                storedServer = localStorage.getItem(this.SERVER_KEY),
                thisCredentials = false;
            if (storedCredentials && storedServer) {
                try {
                    thisCredentials = {
                        credentials: JSON.parse(storedCredentials),
                        server: storedServer
                    };
                } catch (e) {
                    // Malformed JSON
                    return false;
                }
            }
            return thisCredentials;
        },
        /**
         *  Saves the credentials into localStorage
         *  @param {Object} credentials The credentials object
         *  @param {String} server The server string
         */
        set: function (credentials, server) {
            localStorage.setItem(this.CREDENTIALS_KEY, JSON.stringify(credentials));
            localStorage.setItem(this.SERVER_KEY, server);
        },
        /**
         *  Clears the credentials from localStorage
         */
        clear: function () {
            localStorage.removeItem(this.CREDENTIALS_KEY);
            localStorage.removeItem(this.SERVER_KEY);
        }
    };

    // If applicable, overrides default credentials storage implementation with a
    // custom one that was passed into the constructor
    credentialsStore = customCredentialStore || defaultCredentialsStore;

    // Public methods
    return {
        authenticate: authenticateWithServer,
        call: call,
        multiCall: multiCall,
        forget: forget,
        getSession: getSession
    };
};

if (typeof define !== 'undefined' && define.amd) {
    // AMD. Register as an anonymous module.
    define(function () {
        'use strict';
        return GeotabApi;
    });
}

module.export = GeotabApi;```


## File: ./src/.dev/advancedGroupFilter/advancedGroupFilterListener.js

```js
const GroupListeners = require('../groups/GroupListeners.js')

class AdvancedGroupFilterListener {
    constructor () {
        this.displayBox = document.getElementById('advanced-group-filter')
        this.newConditionButton = document.getElementById('advanced-filter-add-condition-button')
        this.cancelBtn = document.getElementById('advanced-filter-cancel-button')
        this.applyFiltersBtn = document.getElementById('advanced-filter-apply-button')
        this.conditionsList = document.getElementById('advanced-conditions-list')
        this.filterBtn = document.getElementById('open-filter-button')
        this.conditionsState = []
        this.conditionCount = 0
    }

    assignListeners() {
        // Creates a new list item when the add condition button is clicked
        this.newConditionButton.addEventListener('click', () => this._addCondition())

        // Cancel button closes popup and removes all conditions
        this.cancelBtn.addEventListener('click', () => this._cancelFilters())

        // Apply filters button closes popup but keeps all conditions
        this.applyFiltersBtn.addEventListener('click', () => this._applyFilters())

        // Show advanced filter popup when button is clicked from original filter dropdown menu
        this.filterBtn.addEventListener('click', () => this._showAdvancedGroupFilter())
    }

    // Show the advnaced filter popup
    _showAdvancedGroupFilter() {
        conditions.original_filter.groupsFilter.state._activeGroups = []
        conditions.original_filter.groupsFilter.writeActiveGroups()
        let filter = document.getElementById('advanced-group-filter')
        filter.style.display = 'block'
    }

    // Add a condition to the advanced filter
    // Switcher section div is for the AND/OR switcher before the condition (doesn't show for first condition)
    // Left column contains the AND/OR switcher for the condition itself
    // Right column contains the group selection and remove button
    // Group wrapper contains the dropdown menu, toggle button, active groups, and clear active groups button
    _addCondition() {
        this.conditionsList.insertAdjacentHTML('beforeend', `
            <li id='condition${this.conditionCount}' class='section form__section'>
                <div class='section__inter-section-switcher'>
                    <span class='geo-switcher' id='condition${this.conditionCount}-switcher'>
                        <input type='radio' id='condition${this.conditionCount}-inter-and' name='condition${this.conditionCount}-inter-operator' class='switcher geo-switcher__input' checked></input>
                        <label for='condition${this.conditionCount}-inter-and' class='geo-switcher__label' centeredLabelText onLabelSwitcher'>AND</label>
                        <input type='radio' id='condition${this.conditionCount}-inter-or ' name='condition${this.conditionCount}-inter-operator' class='switcher geo-switcher__input'></input>
                        <label for='condition${this.conditionCount}-inter-or ' class='geo-switcher__label' centeredLabelText onLabelSwitcher'>OR</label>
                    </span>
                </div>
                <div class='section__main'>
                    <div class='section__col section__col--left'>
                        <label class='section__label'>Operator</label>
                        <div class='section__switcher'>
                            <span class='geo-switcher' id='condition${this.conditionCount}-operator'>
                                <input type='radio' id='condition${this.conditionCount}-and' name='condition${this.conditionCount}-operator' class='switcher geo-switcher__input' checked></input>
                                <label for='condition${this.conditionCount}-and' class='geo-switcher__label' centeredLabelText onLabelSwitcher'>AND</label>
                                <input type='radio' id='condition${this.conditionCount}-or ' name='condition${this.conditionCount}-operator' class='switcher geo-switcher__input'></input>
                                <label for='condition${this.conditionCount}-or ' class='geo-switcher__label' centeredLabelText onLabelSwitcher'>OR</label>
                            </span>
                        </div>
                    </div>
                    <div class='section__col section__col--right'>
                        <label class='section__label'>Groups</label>
                        <button id='condition${this.conditionCount}-remove' class='section__remove-button geo-button geo-button--link'>Remove condition</button>
                        <div id='group-wrapper' class='section__groups node-select-container'>
                            <div class='entity-navigator-container node-select-container__control advanced-filter-dropdown-groups'>
                                <div class='geo-secondary-button-with-expand geotab-filter__wrapper node-select-container__control-element node-select-container__control-element--spacing-right'>
                                    <input id='condition${this.conditionCount}-search' class='inputBox geo-secondary-button-with-expand__input geotab-filter__input' type='text' placeholder='Select groups...'></input>
                                    <button id='condition${this.conditionCount}-dropdown-toggle' class='geo-secondary-button-with-expand__expand geotab-filter__expand group-toggle-button'>
                                        <svg class="svgIcon geotabIcons_chevron" style="height: 15px; width: 15px;"></svg>
                                    </button>
                                </div>
                                <div id='condition${this.conditionCount}-group-dropdown'>
                                    <div id='condition${this.conditionCount}-filter-dropdown' class='geotabPrimaryFill'></div>
                                </div>
                            </div>
                            <div class='currentState node-select-container__state'>
                                <div class='stateItem closeCrossStateItem'>
                                    <div id='condition${this.conditionCount}-active-groups' class='stateItem__text'>Active Groups: ALL</div>
                                    <button id='condition${this.conditionCount}-clear-group' class='filterCloseButton'></button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>
        `)
        
        // Remove the condition when the remove button is clicked
        button = document.getElementById(`condition${this.conditionCount}-remove`)
        button.addEventListener('click', (button) => this._handleRemoveCondition(button))

        operator = document.getElementById(`condition${this.conditionCount}-operator`)
        operator.addEventListener('click', (button) => this._handleToggleOperator(button))

        switcher = document.getElementById(`condition${this.conditionCount}-switcher`)
        switcher.addEventListener('click', (button) => this._handleToggleSwitcher(button))

        // Create a new group listener for each condition
        local_state = {
            _activeGroups: [],
            operator: 'AND',
            switcher: 'AND'
        }
        groupListener = new GroupListeners(global.api, local_state, `condition${this.conditionCount}`, `condition${this.conditionCount}-filter-dropdown`, `condition${this.conditionCount}-group-dropdown`, `condition${this.conditionCount}-search`, `condition${this.conditionCount}-dropdown-toggle`, `condition${this.conditionCount}-clear-group`, `condition${this.conditionCount}-active-groups`);
        groupListener.assignEventListeners();        

        // Increment counter to ensure each condition has a unique name
        this.conditionCount ++
    }

    _handleToggleOperator(button) {
        operator = button.srcElement.id.slice(-3)
        id = button.srcElement.id.slice(0, -4)
        if (operator === 'and') {
            conditions[id].groupsFilter.state.operator = 'AND'
            conditions[id].groupsFilter.writeActiveGroups()
        }
        if (operator === 'or ') {
            conditions[id].groupsFilter.state.operator = 'OR'
            conditions[id].groupsFilter.writeActiveGroups()
        }
    }

    _handleToggleSwitcher(button) {
        switcher = button.srcElement.id.slice(-3)
        id = button.srcElement.id.slice(0, -10)
        if (switcher === 'and') {
            conditions[id].groupsFilter.state.switcher = 'AND'
        }
        if (switcher === 'or ') {
            conditions[id].groupsFilter.state.switcher = 'OR'
        }

    }

    // Remove condition
    _handleRemoveCondition(button) {
        id = button.srcElement.id.slice(0, -7)
        condition = document.getElementById(id)
        condition.remove()
        delete conditions[id]
    }

    // Remove all conditions and hide popup
    _cancelFilters() {
        this.displayBox.style.display = 'none'
        this.conditionsList.innerHTML = ''
        for (let i = 0; i < this.conditionCount; i++) {
            delete conditions[`condition${i}`]
        }
        this.conditionCount = 0
    }

    // Keep conditions and hide popup
    _applyFilters() {
        for (let i = 0; i < this.conditionCount; i++) {
            if (conditions[`condition${i}`]) {
                if (conditions[`condition${i}`].groupsFilter.state._activeGroups.length > 0) {
                    this.conditionsState.push(conditions[`condition${i}`].groupsFilter)
                }
            }
        }
        this._createFilterObject()
        this._writeAdvancedFilter()
        this.displayBox.style.display = 'none'
    }

    _createFilterObject() {
        filter_obj = {}
        for (let i = 0; i < this.conditionsState.length; i++) {
            condition = this.conditionsState[i]
            if (condition.state._activeGroups.length === 1) {
                obj = {"groupId": condition.state._activeGroups[0].id}
            }
            else {
                obj = {
                    "relation": condition.state.operator,
                    "groupFilterConditions": []
                }
                for (j in condition.state._activeGroups) {
                    obj["groupFilterConditions"].push({"groupId": condition.state._activeGroups[j].id})
                }
            }
            if (i != 0) {
                filter_obj = {
                    "relation": condition.state.switcher,
                    "groupFilterConditions": [
                        filter_obj,
                        obj
                    ]
                }
            }
            else {
                filter_obj = obj 
            }
        }
        window.state._advancedGroupsFilter = filter_obj
        global.geotab.addin.geotabDriveScratchie.focus(global.api, global.state);
    }

    _writeAdvancedFilter() {
        text = `Active Groups: `
        for (let i = 0; i < this.conditionsState.length; i++) {
            condition = this.conditionsState[i]
            if (i != 0) {
                text += ` ${condition.state.switcher} `
            }
            if (this.conditionsState.length > 1 && condition.state._activeGroups.length > 1) {
                text += `(`
            }
            for(let j = 0; j < condition.state._activeGroups.length; j++){
                let id = condition.state._activeGroups[j].id;
                let name = condition.groupsDictionary[id].name;
    
                if(j === 0){
                    text += name;
                } else {
                    text += ` ${condition.state.operator} ${name}`;
                }
            } 
            if (this.conditionsState.length > 1 && condition.state._activeGroups.length > 1) {
                text += `)`
            }
        }
        conditions.original_filter.groupsFilter.activeLabel.innerHTML = text
        this.conditionsState = []
    }
}

module.exports = AdvancedGroupFilterListener```


## File: ./src/.dev/advancedGroupFilter/advancedGroupFilter.js

```js
// HTML for the advanced group filter popup
let body = document.getElementsByTagName('body')[0];
let advancedGroupFilter = `
<link rel='stylesheet' href='https://mypreview.geotab.com/geotab/checkmate/main.css?skin=my_geotab'>

<style>
.geo-dialog {
    display: none;
    left:50%;
    top:50%;
    transform: translate(-50%, -50%)
}

.advanced-groups-filter {
    max-height: 75vh;
    overflow-y: auto;
}

.advanced-filter-dropdown-groups {
    flex-direction: column;
}
</style>

<div id='advanced-group-filter' class='geo-dialog'>
    <div class='geo-dialog__header'>
        <div class='geo-dialog__title ellipsis'>Advanced Group Filter</div>
    </div>
    <div class='geo-dialog__content'>
        <div class='form advanced-groups-filter'>
            <div class='form__desc'>Create conditions below to filter the entire system.</div>
            <ul id='advanced-conditions-list' class='sections form__sections'></ul>
            <div class='form__add-section'>
                <button id='advanced-filter-add-condition-button' class='add-section__button geo-button geo-caption'>Add new condition</button>
            </div>
        </div>
    </div>
    <div class='geo-dialog__footer'>
        <button id='advanced-filter-cancel-button' class='geo-button'>Cancel</button>
        <button id='advanced-filter-apply-button' class='geo-button geo-button--action'>Apply filters</button>
    </div>

</div>
`
body.innerHTML = advancedGroupFilter + body.innerHTML;```


## File: ./src/.dev/loaders/css-sandbox/css-sandbox.js

```js
const css = require('css');

function prefixRules(rules, prefix){
    for(let i = 0; i< rules.length; i++){
        // If there are nested rules, we want to prefix those as well
        if(rules[i].rules){
            prefixRules(rules[i].rules, prefix);
        }

        // If there are no selectors in the rules, we leave it alone
        if(!rules[i].selectors){
            continue;
        }

        // Iterating all the selectors present and appending the given prefix to them
        rules[i].selectors = rules[i].selectors.map( selector => prefix + ' ' + selector);
    }
}

module.exports = function(content){
    let prefix = this.query.prefix;
    let cssObj;
    if(!prefix){
        this.emitError(Error('Prefix not provided in options. CSS not prefixed'));
    } else {
        cssObj = css.parse(content);
        if(cssObj.type === 'stylesheet'){
            if(cssObj.stylesheet && cssObj.stylesheet.rules){
                let rules = cssObj.stylesheet.rules;
                prefixRules(rules, prefix);
            }
        }
    }

    return css.stringify(cssObj);
}```


## File: ./src/.dev/login/takePictureDialog/CaptureImageDialog.js

```js
const Dialog = require('./Dialog');

/**
 * Generates take picture dialog content
 * 
 * Displayed when user chooses to upload a new picture
 */
class CaptureImageDialog {

    constructor() {
        this.id = 'capture-image';
        this.dialog = new Dialog(this.id);
        this.app = document.querySelector('#geotabDriveScratchie-app');
    }

    /**
     * Draws image to canvas element using camera and video element as the source
     */
    setImageFromVideoFrame() {
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        var video = document.getElementById('player');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
    }

    generateVideo() {
        var video = document.createElement('video');
        video.setAttribute('id', 'player');
        video.setAttribute('controls', '');
        video.setAttribute('autoplay', '');
        video.setAttribute('width', 320);
        video.setAttribute('height', 240);
        video.style.marginLeft = 'auto';
        video.style.marginRight = 'auto';
        video.style.display = 'block';

        var constraints = {
            video: true,
        };
        navigator.mediaDevices.getUserMedia(constraints)
            .then((stream) => {
                video.srcObject = stream;
        });
        return video;
    }

    generateInnerDialog() {
        var innerDialog = document.createElement('div');
        innerDialog.setAttribute('class', 'dialog-box__inner-wrapper');
        var dialogContent = document.createElement('div');
        dialogContent.setAttribute('class', 'dialog-box__inner');
        dialogContent.setAttribute('id', `${this.id}-inner`);
        innerDialog.appendChild(dialogContent);
        
        return innerDialog;
    }

    generateButtonRegion() {
        var buttonRegion = document.createElement('div');
        buttonRegion.setAttribute('class', 'dialog-box__button-region');
        var buttonRowDiv = document.createElement('div');
        buttonRowDiv.setAttribute('class', 'dialog-box__button-row');
        buttonRegion.appendChild(buttonRowDiv);

        var captureImageButton = document.createElement('button');
        captureImageButton.setAttribute('class', 'dialog-box__button');
        captureImageButton.setAttribute('id', 'takePicture');
        captureImageButton.innerHTML = 'Capture';
        captureImageButton.addEventListener('click', () => {
            this.setImageFromVideoFrame();
            var submitButton = document.getElementById('submitImage');
            // Simulate submit button click so that api promise can be resolved
            submitButton.click();
        });
        buttonRowDiv.appendChild(captureImageButton);
        return buttonRegion;
    }

    /**
     * Generates take picture content and appends it to the dialog box
     */
    generateContent() {
        var dialogBox = this.dialog.generateDialog();
        var video = this.generateVideo();
        var innerDialog =this.generateInnerDialog();
        innerDialog.appendChild(video);
        var buttonRegion = this.generateButtonRegion();

        dialogBox.appendChild(innerDialog);
        dialogBox.appendChild(buttonRegion);
    }
}

module.exports = CaptureImageDialog;
```


## File: ./src/.dev/login/takePictureDialog/UploadImageDialog.js

```js
const CaptureImageDialog = require('./CaptureImageDialog');
const Dialog = require('./Dialog');

/**
 * Generates image options dialog content
 * 
 * Initial dialog box displayed when api.mobile.camera.takePicture() called
 */
class UploadImageDialog {

    constructor () {
        this.id = 'select-image';
        this.dialog = new Dialog(this.id);
        this.app = document.querySelector('#geotabDriveScratchie-app');
    }

    /**
     * Reads file input by user and draws it to canvas element for later base64 extraction
     * 
     * @param {event} evt Change event for file input 
     */
    setImageFromUpload(evt) {
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        var imageFile = evt.target.files[0];
        var fileReader = new FileReader();
        var img = new Image();

        img.onload = () => {
            context.canvas.width = img.width;
            context.canvas.height = img.height;
            context.drawImage(img, 0, 0, canvas.width, canvas.height);
        }
        fileReader.onloadend = () => {
            img.src = fileReader.result;
        }
        fileReader.readAsDataURL(imageFile);
    }

    generateDialogHeader() {
        var titleBar = document.createElement('div');
        titleBar.setAttribute('class', 'dialog-box__header');
        var title = document.createElement('span');
        title.setAttribute('class', 'dialog-box__title heading-3');
        title.setAttribute('id', `${this.id}-title`);
        title.innerHTML = 'Adding Image...';
        titleBar.appendChild(title);

        let closeButton = document.createElement('button');
        closeButton.setAttribute('class', 'dialog-box__close-button');
        closeButton.setAttribute('id', `closeButton-${this.id}`);
        closeButton.innerHTML = '<span style="color: #066ea8">&times</span>';
        closeButton.setAttribute('aria-label', 'Close');
        closeButton.addEventListener('click', () => {
            // Simulate exit button click so api promise can be rejected
            var exitBtn = document.getElementById('exit');
            exitBtn.click();
        });
        titleBar.appendChild(closeButton);
        return titleBar;
    }

    generateInnerDialog() {
        var innerDialog = document.createElement('div');
        innerDialog.setAttribute('class', 'dialog-box__inner-wrapper');
        var dialogContent = document.createElement('div');
        dialogContent.setAttribute('class', 'dialog-box__inner');
        dialogContent.setAttribute('id', `${this.id}-inner`);
        dialogContent.innerHTML = 'Please choose an option to add an image.';
        innerDialog.appendChild(dialogContent);
        return innerDialog;
    }

    /**
     * Generates button region and adds event listeners to buttons
     */
    generateButtonRegion() {
        var buttonRegion = document.createElement('div');
        buttonRegion.setAttribute('class', 'dialog-box__button-region');
        var buttonRowDiv = document.createElement('div');
        buttonRowDiv.setAttribute('class', 'dialog-box__button-row');
        buttonRegion.appendChild(buttonRowDiv);

        var newPictureButton = document.createElement('button');
        newPictureButton.setAttribute('class', 'dialog-box__button');
        newPictureButton.setAttribute('id', 'takePicture');
        newPictureButton.innerHTML = 'New Picture';
        newPictureButton.addEventListener('click', () => {
            // Check if media devices are supported before generating the camera interface
            var isSupported = 'mediaDevices' in navigator;
            if (!isSupported) {
                console.error('Media devices not supported in this browser.');
                return;
            }
            // Do not want to remove utility buttons and their event listeners, only visible dialog
            var removedVisibleDialog = this.dialog.removeAllDialog();
            if (removedVisibleDialog) {
                var captureImageDialog = new CaptureImageDialog();
                this.dialog = captureImageDialog.dialog;
                captureImageDialog.generateContent();
            }
        });
        buttonRowDiv.appendChild(newPictureButton);

        var uploadPictureInput = document.createElement('input');
        uploadPictureInput.setAttribute('type', 'file');
        uploadPictureInput.setAttribute('accept', 'image/*');
        uploadPictureInput.setAttribute('id', 'file-upload');
        uploadPictureInput.style.display = 'none';
        uploadPictureInput.addEventListener('change', (evt) => {
            this.setImageFromUpload(evt);
            var submitButton = document.getElementById('submitImage');
            // small timeout needed to load image before base64 can be extracted from canvas
            setTimeout(() => {
                // Simulate submit button click so that api promise can be resolved
                submitButton.click();
            }, 50);
        });
        
        // HTML file input styling does not match other buttons
        // This button is used for simulating click on file input
        var uploadPictureButton = document.createElement('button');
        uploadPictureButton.setAttribute('class', 'dialog-box__button');
        uploadPictureButton.setAttribute('id', 'uploadPicture');
        uploadPictureButton.innerHTML = 'Upload';
        uploadPictureButton.addEventListener('click', () => {
            uploadPictureInput.click();
        });
        buttonRowDiv.appendChild(uploadPictureButton);
        buttonRowDiv.appendChild(uploadPictureInput);
        return buttonRegion;
    }

    /**
     * Generates upload image options content then appends it to the dialog box
     */
    generateContent() {
        this.dialog.generateDialog();
        var dialogBox = document.getElementById(`${this.id}`);

        var header = this.generateDialogHeader();
        dialogBox.classList.add('_closable');
        dialogBox.classList.add('_titled');
        dialogBox.setAttribute('aria-labelledby', `${this.id}-title`);
        var innerDialog = this.generateInnerDialog();
        var buttonRegion = this.generateButtonRegion();

        dialogBox.appendChild(header);
        dialogBox.appendChild(innerDialog);
        dialogBox.appendChild(buttonRegion);
    }
}

module.exports = UploadImageDialog;
```


## File: ./src/.dev/login/takePictureDialog/Dialog.js

```js
/**
 * Dialog class for generating a dialog box with overlay
 * 
 * Returns dialog box for appending dialog content
 */

class Dialog {

    /**
    * Param handed in for adding id's to dialog
    * 
    * @param {string} dialogID - dialog component id
    */
    constructor(dialogID) {
        this.dialogID = dialogID;
        this.app = document.querySelector('#geotabDriveScratchie-app');
    }

    /**
     * Attempts to remove all dialog
     * 
     * Returns true or false based on success of removal
     */
    cleanUp() {
        var removeSuccess = this.removeAllDialog();
        if (removeSuccess) {
            // Utility buttons exit and submit should only be removed when exit can be made safely
            this.removeUtilityButtons();
            return removeSuccess;
        }
        return !removeSuccess;
    }

    /**
     * Removes visible dialog from the DOM
     * 
     * Stops removing dialog if video component exists and is not loaded yet.
     * This prevents from user closing UI before video is loaded so that on exit, camera
     * recording can be stopped properly.
     */
    removeAllDialog() {
        var dialogBox = document.getElementById(`${this.dialogID}`);
        var overlay = document.getElementById(`overlay-${this.dialogID}`);
        var canvas = document.getElementById('canvas');
        var video = document.getElementById('player');

        // Attempt to stop video first and return false if not able to
        if (video) {
            try {
                video.srcObject.getVideoTracks().forEach(track => track.stop());
            } catch(err) {
                console.error('Video not loaded yet.', err);
                // Removal unsuccessful since video still running, return false to keep UI so exit can be made properly
                return false;
            }
        }
        if (dialogBox) {
            dialogBox.remove();
        }
        if (overlay) {
            overlay.remove();
        }
        if (canvas) {
            canvas.remove();
        }
        // Successful removal and video stopped
        return true;
    }

    /**
     * Removes invisible utility buttons
     */
    removeUtilityButtons() {
        // These buttons are specifically used to resolve or reject api.mobile.camera.takePicture() promise on click
        var submitBtn = document.getElementById('submitImage');
        var exitBtn = document.getElementById('exit');

        if (submitBtn) {
            submitBtn.remove();
        }
        if (exitBtn) {
            exitBtn.remove();
        }
    }

    generateDialogBox() {
        var dialogBox = document.createElement('div');
        dialogBox.setAttribute('class', 'dialog-box');
        dialogBox.setAttribute('id', `${this.dialogID}`);
        dialogBox.setAttribute('aria-modal', 'true');
        dialogBox.style.zIndex = '8000';
        dialogBox.style.position = 'absolute';
        dialogBox.style.top = '50%';
        dialogBox.style.left = '50%';
        dialogBox.style.opacity = 1;
        dialogBox.style.transform = 'translate(-50%,-50%)';
        dialogBox.style.msTransform = 'translate(-50%,-50%)';
        return dialogBox;
    }

    generateOverlay() {
        var overlay = document.createElement('div');
        overlay.setAttribute('class', 'dialog-box-overlay');
        overlay.setAttribute('id', `overlay-${this.dialogID}`);
        overlay.style.zIndex = '7000';
        overlay.addEventListener('click', () => {
            var exitBtn = document.getElementById('exit');
            exitBtn.click();
        });
        return overlay;
    }

    generateCanvas() {
        // Not displayed, used for drawing image and extracting base64
        var canvas = document.createElement('canvas');
        canvas.setAttribute('id', 'canvas');
        canvas.setAttribute('width', 320);
        canvas.setAttribute('height', 240);
        canvas.setAttribute('class', 'hidden');
        return canvas;
    }

    generateSubmitButton() {
        // Not displayed, used for signaling when promise should be resolved.
        var submitImageButton = document.createElement('button');
        submitImageButton.setAttribute('id', 'submitImage');
        submitImageButton.style.display = 'none';
        return submitImageButton;
    }

    generateExitButton() {
        // Not displayed, used for signaling when promise should be rejected.
        var exitButton = document.createElement('button');
        exitButton.setAttribute('id', 'exit');
        exitButton.style.display = 'none';
        return exitButton;
    }

    /**
     * Generates dialog HTML and appends to app component of drive addin
     * 
     * Returns dialog box for appending content
     */
     generateDialog() {
        // Need single instance of these buttons
        var exitBtnExists = document.getElementById('exit') != null;
        var submitBtnExists = document.getElementById('submitImage') != null;
        if (!exitBtnExists)  {
            var exitBtn = this.generateExitButton();
            this.app.appendChild(exitBtn);
        }
        if (!submitBtnExists) {
            var submitBtn = this.generateSubmitButton();
            this.app.appendChild(submitBtn);
        }

        var canvas = this.generateCanvas();
        var dialogBox = this.generateDialogBox();
        var overlay = this.generateOverlay();

        this.app.appendChild(dialogBox);
        this.app.appendChild(overlay);
        this.app.appendChild(canvas);

        return dialogBox;
    }
}

module.exports = Dialog;
```


## File: ./src/.dev/login/loginLogic.js

```js
'use strict';
const config = require('../../config.json');

const ImageOptions = require('./takePictureDialog/UploadImageDialog');


/**
 * Geotab login class
 * 
 * Grabs the login screen, appends listeners, and creates the global
 * api object
 */
class GeotabLogin {

    /**
     * Constructor class -> Replaces the self firing function used with Gulp
     * @param {bool} isDriveAddin whether or not the addin is a drive addin
     * @param {Class} GeotabApi uninstantiated GeotabApi class
     */
    constructor(isDriveAddin, GeotabApi){
        global.api;
        global.state;
        this.elLoginDialog = document.querySelector('#loginDialog');
        this.elEmail = this.elLoginDialog.querySelector('#email');
        this.elPassword = this.elLoginDialog.querySelector('#password');
        this.elServer = this.elLoginDialog.querySelector('#server');
        this.elDatabase = this.elLoginDialog.querySelector('#database');
        this.elLoginError = this.elLoginDialog.querySelector('#loginError');
        this.elLoginBtn = this.elLoginDialog.querySelector('#loginBtn');
        this.elDeviceDialog = document.querySelector('#deviceDialog');
        this.elDevices = this.elDeviceDialog.querySelector('#devices');
        this.elDevicesOkBtn = this.elDeviceDialog.querySelector('#okBtn');
        this.elLogoutBtn = document.querySelector('#logoutBtn');
        this.elAddinButton = document.querySelector('.customButton');
        this.elNightModeToggle = document.querySelector('#nightMode');
        this.elStartStopToggle = document.querySelector('#startStopBtn');
        this.elSendNotification = document.querySelector('#sendNotificationBtn');
        this.elCancelNotification = document.querySelector('#cancelNotificationBtn');
        this.elUpdateNotification = document.querySelector('#updateNotificationBtn');
        this.elPermissionNotification = document.querySelector('#permissionNotificationBtn');
    
        if (this.elAddinButton) {
            this.elAddinButton.addEventListener('click', function (e) {
                Object.keys(global.geotab.customButtons).forEach(function (name) {
                    global.geotab.customButtons[name](e, global.api, global.state);
                });
            });
        }

        this.authenticationCallback;
        this.device = JSON.parse(localStorage.getItem('_device'));

        this.initializeGeotabApi(GeotabApi);
        this.intializeInterface(isDriveAddin);
    }

    initializeGeotabApi(GeotabApi) {
        global.api = new GeotabApi((detailsCallback) => {
            this.authenticationCallback = detailsCallback;

            if (!this.elLoginDialog.open) {
                this.elLoginDialog.showModal();
            }
        }, {
            rememberMe: true
        });
    }

    initializeAddin(isDriveAddin) {
        const meta = { solutionId: config?.solutionId ? config?.solutionId : '' }
        Object.keys(global.geotab.addin).forEach(function (name) {
            var addin = global.geotab.addin[name];

            if (addin.isInitialize) {
                addin.focus(global.api, global.state);
            } else {
                addin = typeof addin === 'function' ? global.geotab.addin[name] = addin(global.api, global.state, meta) : addin;
                if(config.onStartup && isDriveAddin){
                    addin.startup(global.api, global.state, function () {
                        //call initialize after startup
                        addin.initialize(global.api, global.state, function () {
                            addin.isInitialize = true;
                            addin.focus(global.api, global.state);
                        });
                    });
                }
                else{
                    addin.initialize(global.api, global.state, function () {
                        addin.isInitialize = true;
                        addin.focus(global.api, global.state);
                    });
                }
            }
        });
    }

    initializeDevice() {
        // Mock device for drive addin
        global.api.call('Get', {
            typeName: 'Device',
            resultsLimit: 1000,
            search: {
                fromDate: new Date()
            }
        }, (devices) => {
            var options = devices.sort(function (d1, d2) {
                var name1 = d1.name.toLowerCase();
                var name2 = d2.name.toLowerCase();
                if (name1 < name2) {
                    return -1;
                } else if (name1 > name2) {
                    return 1;
                } else {
                    return 0;
                }
            }).map(function (d) {
                return '<option value="' + d.id + '">' + d.name + '</option>';
            });
            this.elDevices.innerHTML = '<option>Select Device</option>' + options.join('');
            this.elDeviceDialog.showModal();
        }, (e) => {
            console.error(`Could not get vehicles: ${e.message}`);
        });
    }

    intializeInterface(isDriveAddin) {
        this.elLoginBtn.addEventListener('click', (event) => {
            var server = this.elServer.value || 'my.geotab.com',
                database = this.elDatabase.value,
                email = this.elEmail.value,
                password = this.elPassword.value;

            event.preventDefault();
            localStorage.setItem('_user', JSON.stringify(email));

            global.api.user = email;
            this.elLoginError.style.display = 'none';

            this.authenticationCallback(server, database, email, password, (err) => {
                this.elLoginDialog.showModal();

                if (err) {
                    this.elLoginError.textContent = err;
                }

                this.elLoginError.style.display = 'block';
            });

            if (!isDriveAddin) {
                this.initializeAddin(isDriveAddin);
            }

            this.elLoginDialog.close();
        });

        this.elLogoutBtn.addEventListener('click', (event) => {
            event.preventDefault();
            if(config.onShutdown && isDriveAddin){
                Object.keys(global.geotab.addin).forEach(function (name) {
                    global.geotab.addin[name].shutdown(global.api, global.state, function(){});
                });
            }

            if (global.api !== undefined) {
                global.api.forget();
            }

            Object.keys(global.geotab.addin).forEach(function (name) {
                global.geotab.addin[name].isInitialize = false;
            });

            this.device = null;
            global.state.device = this.device;
            localStorage.setItem('_device', JSON.stringify(this.device));
            
            if (isDriveAddin) {
                this.initializeDevice();
            }

            Object.keys(global.geotab.addin).forEach(function (name) {
                global.geotab.addin[name].blur(global.api, global.state);
            });
        });

        this.elDevices.addEventListener('change', (event) => {
            var id = event.target.value;

            event.preventDefault();

            if (id) {
                this.device = {
                    id: id
                };
                global.state.device = this.device;
                localStorage.setItem('_device', JSON.stringify(this.device));
            }
        });

        this.elDevicesOkBtn.addEventListener('click', (event) => {
            event.preventDefault();

            if (this.device) {
                this.initializeAddin(isDriveAddin);

                // in this order becasue zombiejs errors out on close
                this.elDeviceDialog.close();
            }
        });

        if (isDriveAddin) {
            this.elNightModeToggle.addEventListener('click', evt => {
                const NightMode = 'nightMode';
                let app = document.querySelector('#geotabDriveScratchie-app');
                let body = document.body;

                if (this.elNightModeToggle.checked) {
                    app.classList.add(NightMode);
                    body.classList.add(NightMode);
                } else {
                    app.classList.remove(NightMode);
                    body.classList.remove(NightMode);
                }
            });

            this.elStartStopToggle.addEventListener('click', evt => {                 
                if (this.elStartStopToggle.classList.contains('start')) {
                    this.elStartStopToggle.classList.remove('start');
                    this.elStartStopToggle.classList.add('stop');  
                    this.elStartStopToggle.innerHTML = 'Stop add-in';
                    Object.keys(global.geotab.addin).forEach(function (name) {
                        var addin = global.geotab.addin[name];
                        addin.isInitialize = false;
                    });
                    this.initializeAddin(isDriveAddin);
                } else {
                    this.elStartStopToggle.classList.remove('stop');
                    this.elStartStopToggle.classList.add('start');
                    this.elStartStopToggle.innerHTML = 'Start add-in';
                    Object.keys(global.geotab.addin).forEach(function (name) {
                        global.geotab.addin[name].shutdown(global.api, global.state, function(){});                
                    }); 
                }
            });
        }

        if (!isDriveAddin) {
            this.initializeAddin(isDriveAddin);
            return;
        }
        // mock Drive properties
        global.api.mobile = {
            exists: function () {
                return true;
            },
            getVersion: function () {
                return '1.1.1';
            },
            speak: function (message) {
                if (!('SpeechSynthesisUtterance' in window)) {
                    console.log('This browser does not supports speech synthesis');
                } else {
                    var utterThis = new SpeechSynthesisUtterance(message);
                    utterThis.lang = 'en-US';
                    window.speechSynthesis.speak(utterThis);
                }
            },
            notification: {
                hasPermission: function(){
                    var permission = false;
                    if(Notification.permission === 'granted')
                    {
                        permission = true;
                    }
                    return permission;
                },
                requestPermission: function(){
                    return Notification.requestPermission();
                },
                notify: function(message, title, tag){
                    var notification,
                        options = {
                            title: title,
                            body: message,
                            tag: tag
                        };

                    if (Notification.permission === 'granted') {
                        notification = new Notification(title, options);
                    } else if (Notification.permission !== 'denied') {
                        Notification.requestPermission(function (permission) {
                            if (permission === 'granted') {
                                notification = new Notification(title, options);
                            }
                        });
                    }
                    return notification;
                },
                //tag is used to identify a notification, if a notification with same tag
                // exists and has already been dispalyed, previous notification will be closed
                //and new one will be displayed
                update: function(message, title, tag){
                    var notification,
                        options = {
                            title: title,
                            body: message,
                            tag: tag
                        };
                    notification = new Notification(title, options);
                    return notification;
                },
                cancel: function(notification){
                    notification.close();
                },
            },
            camera: {
                takePicture: function() {
                    var imageOptions = new ImageOptions();
                    imageOptions.generateContent();
                    var submitButton = document.getElementById('submitImage');
                    var exitBtn = document.getElementById('exit');

                    return new Promise((resolve, reject) => {
                        exitBtn.onclick = () => {
                            // Making sure UI and recording stopped before returning
                            var removed = imageOptions.dialog.cleanUp();
                            if (removed) {
                                reject('Exited.');
                            }
                        }
                        submitButton.onclick = () => {
                            var canvas = document.getElementById('canvas');
                            var base64;
                            if (canvas) {
                                base64 = canvas.toDataURL('image/png');
                            }
                            // Making sure UI and recording stopped before returning
                            var removed = imageOptions.dialog.cleanUp();
                            if (removed) {
                                if (base64) {
                                    resolve(base64);
                                } else {
                                    reject('Image not loaded correctly.');
                                }
                            }
                        };
                    });
                },
            },
            geolocation: navigator.geolocation
        };

        global.api.user = JSON.parse(localStorage.getItem('_user'));

        // Drive properties
        global.state.device = this.device;
        global.state.driving = true;
        global.state.charging = true;
        global.state.background = false;
        global.state.online = true;
        global.state.deviceCommunicating = true;

        if (!this.device) {
            this.initializeDevice();
        } else {
            this.initializeAddin(isDriveAddin);
        }
    }
}

module.exports = GeotabLogin;
```


## File: ./src/.dev/login/loginTemplate.js

```js
let body = document.getElementsByTagName('body')[0];
import icon from '../images/Font_Awesome_5_solid_chevron-left.svg';
import xIcon from '../images/close-round.svg';
import addinIcon from '../../app/images/icon.svg';
import '../styles/styleGuide.css'
let loginExample = `

    <link rel="stylesheet" href="https://my.geotab.com/geotab/checkmate/main.css">

<style>
    body {
        height: initial;
        width: initial;
    }

    body.nightMode {
        background: #515964;
    }

    body>div {
        margin: 1em;
    }

    button:focus, #navigationId:focus {
        outline: none;
    }

    #geotabDriveScratchie {
        width: initial;
    }

    #hiddenMenu {
        position: absolute;
        display: none;
        top: 0;
        left: 249px;
        min-width: 200px;
        height: auto;
    }

    .geotabIcons_chevron {
        mask-image: url(${icon});
        mask-repeat: no-repeat;
        -webkit-mask-image: url(${icon});
        -webkit-mask-repeat: no-repeat;
        background-color: #25477b;
    }

    .dev-dialog {
        
        border: 1px solid rgba(0, 0, 0, 0.3);
        border-radius: 6px;
        box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);
    }

    .dev-dialog::backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
    }

    .dev-header {
        display: flex;
        background-color: #eee;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-end;
        border-bottom: 1px solid #ccc;
    }

    .group-toggle-button svg {
        mask-image: url(${icon});
        mask-repeat: no-repeat;
        -webkit-mask-image: url(${icon});
        -webkit-mask-repeat: no-repeat;
        background-color: #666;
        transform: rotate(-90deg);
    }

    .group-wrapper {
        display: flex;
        flex-direction: row;
        flex-wrap: nowrap;
        flex: 1;
        padding-left: 40px;
    }

    #group-selector {
        display: flex;
        position: relative;
        z-index: 10003;
        margin: 0.5em 0;
    }

    #group-input {
        border: none;
        z-index: 10003;
        text-decoration: none;
    }

    #group-input:focus {
        outline-style: none;
    }

    #group-input::placeholder {
        font-weight: bold;
        text-decoration: none;
    }

    #active-group {
        padding: 5px 10px;
        margin: 0.5em 0.5em 0.5em 0;
        font-weight: bold;
        color: #666;
    }

    .navButton {
        display: block;
    }

    .select-buttons {
        list-style-type: none;
        padding: 0;
    }

    .select-buttons li {
        margin: 3px 10px 0px 10px;
    }

    #group-dropdown {
        display: none;
        position: absolute;
        top: 40px;
        width: 250px;
        z-index: 10003;
        min-height: auto;
        max-height: 80vh;
        overflow-y: auto;
        border: 1px solid #ccc;
    }

    #group-remove-all {
        padding: 5px 10px;
        display: none;
        border: none;
        width: 20px;
        height: 20px;
        cursor: pointer;
        margin: 0.5em 0.5em 0.5em 0;
    }

    #group-remove-all:focus {
        outline: none;
    }

    #group-remove-all svg {
        mask-image: url(${xIcon});
        mask-repeat: no-repeat;
        -webkit-mask-image: url(${xIcon});
        -webkit-mask-repeat: no-repeat;
        background-color: #666;
    }

    .dev-button {
        padding: 5px 10px;
        display: inline;
        background: #bbb repeat-x bottom;
        border: none;
        color: #fff;
        cursor: pointer;
        font-weight: bold;
        border-radius: 5px;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        text-shadow: 1px 1px #666;
        text-decoration: none;
        margin: 0.5em 0.5em 0.5em 0;
    }

    .dev-button:hover {
        background-position: 0 -48px;
        filter: brightness(108%);
    }

    .dev-button:active {
        background-position: 0 top;
        position: relative;
        top: 1px;
        padding: 6px 10px 4px;
    }

    .dev-toggle {
        flex: auto;
        padding: 12px 10px;
    }

    .dev-form {
        flex-direction: column;
        flex-wrap: wrap;
        justify-content: flex-end;
        display: flex;
    }

    .dev-form label {
        display: none;
    }

    .dev-form input,
    .dev-form select {
        border-radius: 0.5em;
        padding: 0.5em;
    }

    .dev-form input {
        border-radius: 0.5em;
        padding: 0.5em;
    }

    .dev-form .line {
        display: block;
        margin: 0.5em 0;
    }

    .geotabIcons_geotabDriveScratchie {
        background-image: url("${addinIcon}");
    } 
    </style>
    <header class="dev-header">
    
        <label class="dev-toggle">Night-Mode
            <input type="checkbox" id="nightMode" />
        </label>
        <a id="toggleBtn" class="dev-button">Blur add-in</a>
        <a id="startStopBtn" class="dev-button stop">Stop add-in</a>        
      
      <a target="_blank" href="https://geotab.github.io/sdk/software/guides/developing-addins/addin-icon-validator.html" class="dev-button">SVG Icon Validor</a>
      <a id="logoutBtn" class="dev-button">Logout</a>
    </header>

    <dialog id="loginDialog" class="dev-dialog">
        <form class="dev-form">
            <div class="line">
                <label for="email">Email</label>
                <input type="text" id="email" placeholder="Email">
            </div>
            <div class="line">
                <label for="password">Password</label>
                <input type="password" id="password" placeholder="Password">
            </div>
            <div class="line">
                <label for="server">Server</label>
                <input type="text" id="server" placeholder="Server URL (my.geotab.com)">
            </div>
            <div class="line">
                <label for="database">Database</label>
                <input type="text" id="database" placeholder="Database">
            </div>
            <div class="line error" id="loginError" style="display: none; color: red">
                Invalid User or Password
            </div>
            <div class="line">
                <a href="" id="loginBtn" class="dev-button">Login</a>
            </div>
        </form>
    </dialog>
    <dialog id="deviceDialog" class="dev-dialog">
        <form class="dev-form">
            <div class="line">
                <label for="devices">Device</label>
                <select id="devices"></select>
            </div>
            <div class="line">
                <a href="" id="okBtn" class="dev-button">OK</a>
            </div>
        </form>
    </dialog>
`;
body.innerHTML = loginExample + body.innerHTML;
```


## File: ./src/.dev/rison.js

```js
//////////////////////////////////////////////////
//
//  the stringifier is based on
//    http://json.org/json.js as of 2006-04-28 from json.org
//  the parser is based on 
//    http://osteele.com/sources/openlaszlo/json
//

if (typeof rison == 'undefined')
    window.rison = {};

/**
 *  rules for an uri encoder that is more tolerant than encodeURIComponent
 *
 *  encodeURIComponent passes  ~!*()-_.'
 *
 *  we also allow              ,:@$/
 *
 */
rison.uri_ok = {  // ok in url paths and in form query args
    '~': true, '!': true, '*': true, '(': true, ')': true,
    '-': true, '_': true, '.': true, ',': true,
    ':': true, '@': true, '$': true,
    "'": true, '/': true
};

/*
 * we divide the uri-safe glyphs into three sets
 *   <rison> - used by rison                         ' ! : ( ) ,
 *   <reserved> - not common in strings, reserved    * @ $ & ; =
 *
 * we define <identifier> as anything that's not forbidden
 */

/**
 * punctuation characters that are legal inside ids.
 */
// this var isn't actually used
//rison.idchar_punctuation = "_-./~";  

(function () {
    var l = [];
    for (var hi = 0; hi < 16; hi++) {
        for (var lo = 0; lo < 16; lo++) {
            if (hi + lo == 0) continue;
            var c = String.fromCharCode(hi * 16 + lo);
            if (! /\w|[-_.\/~]/.test(c))
                l.push('\\u00' + hi.toString(16) + lo.toString(16));
        }
    }
    /**
     * characters that are illegal inside ids.
     * <rison> and <reserved> classes are illegal in ids.
     *
     */
    rison.not_idchar = l.join('')
    //idcrx = new RegExp('[' + rison.not_idchar + ']');
    //console.log('NOT', (idcrx.test(' ')) );
})();
//rison.not_idchar  = " \t\r\n\"<>[]{}'!=:(),*@$;&";
rison.not_idchar = " '!:(),*@$";


/**
 * characters that are illegal as the start of an id
 * this is so ids can't look like numbers.
 */
rison.not_idstart = "-0123456789";


(function () {
    var idrx = '[^' + rison.not_idstart + rison.not_idchar +
        '][^' + rison.not_idchar + ']*';

    rison.id_ok = new RegExp('^' + idrx + '$');

    // regexp to find the end of an id when parsing
    // g flag on the regexp is necessary for iterative regexp.exec()
    rison.next_id = new RegExp(idrx, 'g');
})();

/**
 * this is like encodeURIComponent() but quotes fewer characters.
 *
 * @see rison.uri_ok
 *
 * encodeURIComponent passes   ~!*()-_.'
 * rison.quote also passes   ,:@$/
 *   and quotes " " as "+" instead of "%20"
 */
rison.quote = function (x) {
    if (/^[-A-Za-z0-9~!*()_.',:@$\/]*$/.test(x))
        return x;

    return encodeURIComponent(x)
        .replace(/%2C/g, ',')
        .replace(/%3A/g, ':')
        .replace(/%40/g, '@')
        .replace(/%24/g, '$')
        .replace(/%2F/g, '/')
        .replace(/%20/g, '+');
};


//
//  based on json.js 2006-04-28 from json.org
//  license: http://www.json.org/license.html
//
//  hacked by nix for use in uris.
//

(function () {
    var sq = { // url-ok but quoted in strings
        "'": true, '!': true
    },
        s = {
            array: function (x) {
                var a = ['!('], b, f, i, l = x.length, v;
                for (i = 0; i < l; i += 1) {
                    v = x[i];
                    f = s[typeof v];
                    if (f) {
                        v = f(v);
                        if (typeof v == 'string') {
                            if (b) {
                                a[a.length] = ',';
                            }
                            a[a.length] = v;
                            b = true;
                        }
                    }
                }
                a[a.length] = ')';
                return a.join('');
            },
            'boolean': function (x) {
                if (x)
                    return '!t';
                return '!f'
            },
            'null': function (x) {
                return "!n";
            },
            number: function (x) {
                if (!isFinite(x))
                    return '!n';
                // strip '+' out of exponent, '-' is ok though
                return String(x).replace(/\+/, '');
            },
            object: function (x) {
                if (x) {
                    if (x instanceof Array) {
                        return s.array(x);
                    }
                    // WILL: will this work on non-Firefox browsers?
                    if (typeof x.__prototype__ === 'object' && typeof x.__prototype__.encode_rison !== 'undefined')
                        return x.encode_rison();

                    var a = ['('], b, f, i, v, ki, ks = [];
                    for (i in x)
                        ks[ks.length] = i;
                    ks.sort();
                    for (ki = 0; ki < ks.length; ki++) {
                        i = ks[ki];
                        v = x[i];
                        f = s[typeof v];
                        if (f) {
                            v = f(v);
                            if (typeof v == 'string') {
                                if (b) {
                                    a[a.length] = ',';
                                }
                                a.push(s.string(i), ':', v);
                                b = true;
                            }
                        }
                    }
                    a[a.length] = ')';
                    return a.join('');
                }
                return '!n';
            },
            string: function (x) {
                if (x == '')
                    return "''";

                if (rison.id_ok.test(x))
                    return x;

                x = x.replace(/(['!])/g, function (a, b) {
                    if (sq[b]) return '!' + b;
                    return b;
                });
                return "'" + x + "'";
            },
            undefined: function (x) {
                throw new Error("rison can't encode the undefined value");
            }
        };


    /**
     * rison-encode a javascript structure
     *
     *  implemementation based on Douglas Crockford's json.js:
     *    http://json.org/json.js as of 2006-04-28 from json.org
     *
     */
    rison.encode = function (v) {
        return s[typeof v](v);
    };

    /**
     * rison-encode a javascript object without surrounding parens
     *
     */
    rison.encode_object = function (v) {
        if (typeof v != 'object' || v === null || v instanceof Array)
            throw new Error("rison.encode_object expects an object argument");
        var r = s[typeof v](v);
        return r.substring(1, r.length - 1);
    };

    /**
     * rison-encode a javascript array without surrounding parens
     *
     */
    rison.encode_array = function (v) {
        if (!(v instanceof Array))
            throw new Error("rison.encode_array expects an array argument");
        var r = s[typeof v](v);
        return r.substring(2, r.length - 1);
    };

    /**
     * rison-encode and uri-encode a javascript structure
     *
     */
    rison.encode_uri = function (v) {
        return rison.quote(s[typeof v](v));
    };

})();




//
// based on openlaszlo-json and hacked by nix for use in uris.
//
// Author: Oliver Steele
// Copyright: Copyright 2006 Oliver Steele.  All rights reserved.
// Homepage: http://osteele.com/sources/openlaszlo/json
// License: MIT License.
// Version: 1.0


/**
 * parse a rison string into a javascript structure.
 *
 * this is the simplest decoder entry point.
 *
 *  based on Oliver Steele's OpenLaszlo-JSON
 *     http://osteele.com/sources/openlaszlo/json
 */
rison.decode = function (r) {
    var errcb = function (e) { throw Error('rison decoder error: ' + e); };
    var p = new rison.parser(errcb);
    return p.parse(r);
};

/**
 * parse an o-rison string into a javascript structure.
 *
 * this simply adds parentheses around the string before parsing.
 */
rison.decode_object = function (r) {
    return rison.decode('(' + r + ')');
};

/**
 * parse an a-rison string into a javascript structure.
 *
 * this simply adds array markup around the string before parsing.
 */
rison.decode_array = function (r) {
    return rison.decode('!(' + r + ')');
};


/**
 * construct a new parser object for reuse.
 *
 * @constructor
 * @class A Rison parser class.  You should probably 
 *        use rison.decode instead. 
 * @see rison.decode
 */
rison.parser = function (errcb) {
    this.errorHandler = errcb;
};

/**
 * a string containing acceptable whitespace characters.
 * by default the rison decoder tolerates no whitespace.
 * to accept whitespace set rison.parser.WHITESPACE = " \t\n\r\f";
 */
rison.parser.WHITESPACE = "";

// expose this as-is?
rison.parser.prototype.setOptions = function (options) {
    if (options['errorHandler'])
        this.errorHandler = options.errorHandler;
};

/**
 * parse a rison string into a javascript structure.
 */
rison.parser.prototype.parse = function (str) {
    this.string = str;
    this.index = 0;
    this.message = null;
    var value = this.readValue();
    if (!this.message && this.next())
        value = this.error("unable to parse string as rison: '" + rison.encode(str) + "'");
    if (this.message && this.errorHandler)
        this.errorHandler(this.message, this.index);
    return value;
};

rison.parser.prototype.error = function (message) {
    if (typeof (console) != 'undefined')
        console.log('rison parser error: ', message);
    this.message = message;
    return undefined;
}

rison.parser.prototype.readValue = function () {
    var c = this.next();
    var fn = c && this.table[c];

    if (fn)
        return fn.apply(this);

    // fell through table, parse as an id

    var s = this.string;
    var i = this.index - 1;

    // Regexp.lastIndex may not work right in IE before 5.5?
    // g flag on the regexp is also necessary
    rison.next_id.lastIndex = i;
    var m = rison.next_id.exec(s);

    // console.log('matched id', i, r.lastIndex);

    if (m.length > 0) {
        var id = m[0];
        this.index = i + id.length;
        return id;  // a string
    }

    if (c) return this.error("invalid character: '" + c + "'");
    return this.error("empty expression");
}

rison.parser.parse_array = function (parser) {
    var ar = [];
    var c;
    while ((c = parser.next()) != ')') {
        if (!c) return parser.error("unmatched '!('");
        if (ar.length) {
            if (c != ',')
                parser.error("missing ','");
        } else if (c == ',') {
            return parser.error("extra ','");
        } else
            --parser.index;
        var n = parser.readValue();
        if (typeof n == "undefined") return undefined;
        ar.push(n);
    }
    return ar;
};

rison.parser.bangs = {
    t: true,
    f: false,
    n: null,
    '(': rison.parser.parse_array
}

rison.parser.prototype.table = {
    '!': function () {
        var s = this.string;
        var c = s.charAt(this.index++);
        if (!c) return this.error('"!" at end of input');
        var x = rison.parser.bangs[c];
        if (typeof (x) == 'function') {
            return x.call(null, this);
        } else if (typeof (x) == 'undefined') {
            return this.error('unknown literal: "!' + c + '"');
        }
        return x;
    },
    '(': function () {
        var o = {};
        var c;
        var count = 0;
        while ((c = this.next()) != ')') {
            if (count) {
                if (c != ',')
                    this.error("missing ','");
            } else if (c == ',') {
                return this.error("extra ','");
            } else
                --this.index;
            var k = this.readValue();
            if (typeof k == "undefined") return undefined;
            if (this.next() != ':') return this.error("missing ':'");
            var v = this.readValue();
            if (typeof v == "undefined") return undefined;
            o[k] = v;
            count++;
        }
        return o;
    },
    "'": function () {
        var s = this.string;
        var i = this.index;
        var start = i;
        var segments = [];
        var c;
        while ((c = s.charAt(i++)) != "'") {
            //if (i == s.length) return this.error('unmatched "\'"');
            if (!c) return this.error('unmatched "\'"');
            if (c == '!') {
                if (start < i - 1)
                    segments.push(s.slice(start, i - 1));
                c = s.charAt(i++);
                if ("!'".indexOf(c) >= 0) {
                    segments.push(c);
                } else {
                    return this.error('invalid string escape: "!' + c + '"');
                }
                start = i;
            }
        }
        if (start < i - 1)
            segments.push(s.slice(start, i - 1));
        this.index = i;
        return segments.length == 1 ? segments[0] : segments.join('');
    },
    // Also any digit.  The statement that follows this table
    // definition fills in the digits.
    '-': function () {
        var s = this.string;
        var i = this.index;
        var start = i - 1;
        var state = 'int';
        var permittedSigns = '-';
        var transitions = {
            'int+.': 'frac',
            'int+e': 'exp',
            'frac+e': 'exp'
        };
        do {
            var c = s.charAt(i++);
            if (!c) break;
            if ('0' <= c && c <= '9') continue;
            if (permittedSigns.indexOf(c) >= 0) {
                permittedSigns = '';
                continue;
            }
            state = transitions[state + '+' + c.toLowerCase()];
            if (state == 'exp') permittedSigns = '-';
        } while (state);
        this.index = --i;
        s = s.slice(start, i)
        if (s == '-') return this.error("invalid number");
        return Number(s);
    }
};
// copy table['-'] to each of table[i] | i <- '0'..'9':
(function (table) {
    for (var i = 0; i <= 9; i++)
        table[String(i)] = table['-'];
})(rison.parser.prototype.table);

// return the next non-whitespace character, or undefined
rison.parser.prototype.next = function () {
    var s = this.string;
    var i = this.index;
    do {
        if (i == s.length) return undefined;
        var c = s.charAt(i++);
    } while (rison.parser.WHITESPACE.indexOf(c) >= 0);
    this.index = i;
    return c;
};

module.exports = rison;
```
